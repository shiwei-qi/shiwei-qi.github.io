<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++11实现线程池</title>
    <url>/2022/05/24/C++11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p><img src="/2022/05/24/C++11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/978956.jpg" alt="978956"></p>
<h1 id="chang-jing">场景</h1>
<p>大多数网络服务器单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。</p>
<p>除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为10000，那么最坏情况下，系统可能需要产生10000个线程。尽管这不是一个很大的数目，但是也有部分机器可能达不到这种要求.</p>
<h1 id="xian-cheng-chi-de-ding-yi">线程池的定义</h1>
<p>事先创建若干空闲的线程放入一个池中（容器），当一个任务提交到线程池时，线程池就会启动一个空闲的线程去处理任务，当任务结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>
<p><img src="/2022/05/24/C++11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f302f30632f5468726561645f706f6f6c2e7376672f35383070782d5468726561645f706f6f6c2e7376672e706e67.png" alt="img"></p>
<h1 id="you-dian">优点</h1>
<ol>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>：当任务到达时，可以不需要等待线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，监控和调优。</li>
</ol>
<p>事实上，线程池并不是万能的。它有其特定的使用场合。线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略</p>
<h1 id="xian-cheng-chi-gong-zuo-de-ji-chong-qing-kuang">线程池工作的几种情况</h1>
<p>按任务队列和线程池大小可分成四种情况：</p>
<ul>
<li>
<p>没有任务，线程池中任务队列为空，啥也不做</p>
<img src="/2022/05/24/C++11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/3805f625e05f8e2d1d0b69910323d7a9.png" alt="空队列情况" style="zoom: 80%;">
</li>
<li>
<p>添加小于等于线程池数量的任务，主线程添加任务后通知唤醒线程池中的线程开始取任务。此时任务缓冲队列还是空</p>
<img src="/2022/05/24/C++11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/b72937b576e8e3e4a0b14ff5a9b3a1b9.png" alt="img" style="zoom:80%;">
</li>
<li>
<p>添加大于线程池数量的任务，继续添加发现线程池用完，于是存入缓冲队列，工作线程空闲后主动从任务队列取任务执行，缓冲队列未满</p>
</li>
</ul>
<img src="/2022/05/24/C++11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/3bc05a0abf3eff2c7e25427e1c2636bb.png" alt="任务数量大于线程池数量" style="zoom:80%;">
<ul>
<li>添加大于线程池数量的任务，且任务队列已满，当线程中线程用完，且任务缓冲队列已满，进入等待状态，等待任务缓冲队列通知</li>
</ul>
<img src="/2022/05/24/C++11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/4a50fc4f32e13a1761c2e687a58a83a4.png" alt="img" style="zoom:80%;">
<h1 id="xian-cheng-chi-de-shi-xian">线程池的实现</h1>
<p>使用C++11中的<code>bind</code>、<code>function</code>定义和调用任务处理函数和<code>std::thread</code>等实现的按照任务优先级先后处理的线程池。</p>
<p><strong>ThreadPool.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//function&lt;void()&gt; 可以认为是一个函数类型，接受任意原型是 void() 的函数，或是函数对象，或是匿名函数。</span></span><br><span class="line">    <span class="comment">//void() 意思是不带参数，没有返回值。</span></span><br><span class="line">    <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; Task_type;<span class="comment">//任务类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">taskPriorityE</span> &#123;LOW, MIDDLE, HIGH&#125;;<span class="comment">//优先级</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;taskPriorityE,Task_type&gt; TaskPair;<span class="comment">//任务优先级和任务类型组合的任务</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> threads_size = <span class="number">4</span>);<span class="comment">//默认线程池大小为4</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;<span class="comment">//终止线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(<span class="type">const</span> Task_type&amp;)</span></span>;<span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(<span class="type">const</span> TaskPair&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//禁用拷贝构造和赋值运算符</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">const</span> ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_started</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_started;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;<span class="comment">//运行线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Task_type <span class="title">take</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> std::vector&lt;std::thread*&gt; Threads_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载()操作符实现优先队列的比较操作</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TaskPriorityCmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> TaskPair&amp; a, <span class="type">const</span> TaskPair&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_threads_size;<span class="comment">//线程池大小</span></span><br><span class="line">    std::vector&lt;std::thread*&gt; m_threads;<span class="comment">//线程池</span></span><br><span class="line">    std::priority_queue&lt;TaskPair, std::vector&lt;TaskPair&gt;, TaskPriorityCmp&gt;  m_tasks;<span class="comment">//任务队列</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutex;<span class="comment">//STL队列不是线程安全的，因此需要结合互斥锁</span></span><br><span class="line">    std::condition_variable m_cond;<span class="comment">//条件变量</span></span><br><span class="line">    <span class="type">bool</span> m_started;<span class="comment">//是否开始</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数通过传入的参数，初始化线程池大小、锁、条件变量、是否开始，之后开始运行</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> threads_size)</span><br><span class="line">    :<span class="built_in">m_threads_size</span>(threads_size), <span class="built_in">m_mutex</span>(), <span class="built_in">m_cond</span>(), <span class="built_in">m_started</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_started)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//start中创建线程，并将线程和任务处理函数进行绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// assert 的作用是现计算表达式 expression,如果其值为假(即为0),那么它先向 stderr 打印一条出错信息,然后通过调用 abort 来终止程序运行。</span></span><br><span class="line">    <span class="built_in">assert</span>(m_threads.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">assert</span>(!m_started);</span><br><span class="line">    m_started = <span class="literal">true</span>;</span><br><span class="line">    m_threads.<span class="built_in">reserve</span>(m_threads_size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; m_threads_size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//函数绑定bind函数用于把某种形式的参数列表与已知的函数进行绑定，形成新的函数</span></span><br><span class="line">        m_threads.<span class="built_in">push_back</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadLoop, <span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池终止，通知所有线程，并将所有线程分离，最后将线程池清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_started = <span class="literal">false</span>;</span><br><span class="line">    m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_threads.<span class="built_in">begin</span>(); it != m_threads.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//等待线程执行直到终止,其实就说join方法将挂起调用线程的执行，直到被调用的对象完成它的执行</span></span><br><span class="line">        (*it)-&gt;<span class="built_in">join</span>();</span><br><span class="line">        <span class="keyword">delete</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    m_threads.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//threadLoop中循环从队列中拿任务并执行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(m_started)</span><br><span class="line">    &#123;</span><br><span class="line">        Task_type task = <span class="built_in">take</span>();</span><br><span class="line">        <span class="keyword">if</span>(task)</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(<span class="type">const</span> Task_type&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="comment">//默认中等优先级</span></span><br><span class="line">    <span class="function">TaskPair <span class="title">taskPair</span><span class="params">(MIDDLE, task)</span></span>;</span><br><span class="line">    m_tasks.<span class="built_in">emplace</span>(taskPair);</span><br><span class="line">    m_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(<span class="type">const</span> TaskPair&amp; taskPair)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_tasks.<span class="built_in">emplace</span>(taskPair);</span><br><span class="line">    m_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从任务队列拿任务</span></span><br><span class="line"><span class="function">ThreadPool::Task_type <span class="title">ThreadPool::take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(m_tasks.<span class="built_in">empty</span>() &amp;&amp; m_started)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cond.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Task_type task;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = m_tasks.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(!m_tasks.<span class="built_in">empty</span>() &amp;&amp; m_started)</span><br><span class="line">    &#123;</span><br><span class="line">        task = m_tasks.<span class="built_in">top</span>().second;</span><br><span class="line">        m_tasks.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">assert</span>(size <span class="number">-1</span> == m_tasks.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>测试代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//此锁是保证输出完整</span></span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;MyFunc()&quot;</span>  &lt;&lt; <span class="string">&quot;at thread [&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] output&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ThreadPool tp;</span><br><span class="line">  mutex mtx;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//这里只添加四次任务，因此任务队列实际大小为4</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      tp.<span class="built_in">addTask</span>(MyFunc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="can-kao-lian-jie">参考链接</h1>
<p><a href="https://github.com/progschj/ThreadPool">https://github.com/progschj/ThreadPool</a></p>
<p><a href="https://github.com/attackoncs/MyThreadPool">https://github.com/attackoncs/MyThreadPool</a></p>
<p><a href="https://github.com/mtrebi/thread-pool">https://github.com/mtrebi/thread-pool</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++异常处理机制</title>
    <url>/2022/05/22/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<img src="/2022/05/22/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/wallhaven-rddgwm.png" alt="wallhaven-rddgwm">
<h1 id="gai-nian">概念</h1>
<p>异常处理就是处理程序中的错误，程序运行时常见异常情况如：</p>
<ul>
<li>做除法的时候除数为 0；</li>
<li>用户输入年龄时输入了一个负数；</li>
<li>用 <code>new</code> 运算符动态分配空间时，空间不够导致无法分配；</li>
<li>访问数组元素时，下标越界；</li>
<li>打开文件读取时，文件不存在。</li>
</ul>
<p>如果不能发现并加以处理，很可能会导致程序崩溃。</p>
<h1 id="yuan-yin">原因</h1>
<ol>
<li>当发生异常，程序无法沿着正常的顺序执行下去的时候，立即结束程序可能并不妥当。我们需要给程序提供另外一条可以安全退出的路径，在结束前做一些必要的工作，如将内存中的数据写入文件、关闭打开的文件、释放动态分配的内存空间等。</li>
<li>当发生异常的时候，程序马上处理可能并不妥当（一个异常有多种处理方法，或者自己无法处理异常），需要将这个异常抛出给他的上级（直接调用者），由上级决定如何处理。或者是自己不处理再转交给它的上级去处理，一直可以转交到最外层的main()函数</li>
<li>另外，异常的分散处理不利于代码的维护，尤其是对于在不同地方发生的同一种异常，都要编写相同的处理代码也是一种不必要的重复和冗余。如果能在发生各种异常时让程序都执行到同一个地方，这个地方能够对异常进行集中处理，则程序就会更容易编写、维护。</li>
</ol>
<p>在引入异常处理机制之前，异常的处理方式有两种方法</p>
<ul>
<li>使用整型的返回值标识错误；</li>
<li>使用<code>errno</code>宏（可以简单的理解为一个全局整型变量）去记录错误。当然C++中仍然是可以用这两种方法的。</li>
</ul>
<p>这两种方法最大的缺陷就是会出现<strong>不一致</strong>问题。例如有些函数返回1表示成功，返回0表示出错；而有些函数返回0表示成功，返回非0表示出错。</p>
<p>还有一个缺点就是函数的返回值只有一个，你通过函数的返回值表示错误代码，那么函数就不能返回其他的值。</p>
<p>鉴于上述原因，C++引入了异常处理机制。</p>
<h1 id="strong-yi-chang-chu-li-de-ji-ben-si-xiang-strong"><strong>异常处理的基本思想</strong></h1>
<blockquote>
<p>在遇到异常时，系统不是马上终止运行，而是允许用户排除错误，继续运行程序，至少给出出错的提示信息。<br>
在大型复杂的软件系统中，函数之间有明显的分工和复杂的调用关系，发现错误的函数一般不具备处理错误的能力。<br>
这时只能导致一个异常，并抛出异常，如果调用者也不能处理就传递给它的上级调用者，这样一直上传到能处理为止。<br>
如果始终没有处理就上交到C++运行系统，运行系统调用<code>abort</code>函数强行终止整个程序。</p>
</blockquote>
<p><img src="/2022/05/22/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/image-20220521202700487.png" alt="image-20220521202700487"></p>
<p>在 <code>h()</code>函数中专注于业务的处理，而不用去处理异常，让 <code>f()</code>函数实现综合的处理.</p>
<ul>
<li>
<p>C++的异常处理机制使得异常的引发和异常的处理不必在同一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理。上层调用者可以再适当的位置设计对不同类型异常的处理。</p>
</li>
<li>
<p>异常是专门针对抽象编程中的一系列错误处理的，C++中不能借助函数机制，因为栈结构的本质是先进后出，依次访问，无法进行跳跃，但错误处理的特征却是遇到错误信息就想要转到若干级之上进行重新尝试。</p>
</li>
<li>
<p>异常超脱于函数机制，决定了其对函数的跨越式回跳。</p>
</li>
</ul>
<p><strong>错误处理示意</strong></p>
<img src="/2022/05/22/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/image-20220521203303981.png" alt="image-20220521203303981">
<h1 id="strong-yi-chang-chu-li-liu-cheng-strong"><strong>异常处理流程</strong></h1>
<p>C++ 异常处理涉及到三个关键字：<strong><code>try</code>、<code>catch</code>、<code>throw</code></strong>。</p>
<p><strong>1、<code>throw</code>:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong><code>throw</code></strong> 关键字来完成的。</p>
<p><strong>2、<code>try</code>:</strong> <strong><code>try</code></strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 <code>catch</code> 块。</p>
<p><strong>3、<code>catch</code>:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong><code>catch</code></strong> 关键字用于捕获异常。</p>
<p>**4、<code>finally</code>：**关键字<code>finally</code>放在<code>catch</code>之后，如果异常没有被<code>catch</code>捕获，会使用关键字去清理释放资源</p>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码（判断异常的类型），try 块中的代码被称为保护代码。catch后面对应每个异常的处理方法。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>
<p>throw后面可跟任何表达式，除了整数外，指针、字符常量等也可以，如：throw “文档打开失败”。</p>
</li>
<li>
<p>通过throw操作创建一个异常对象并抛掷</p>
</li>
<li>
<p>在需要捕捉异常的地方，将可能抛出异常的程序段嵌在try块之中</p>
</li>
<li>
<p>按正常的程序顺序执行到达try语句，然后执行try块{}内的保护段</p>
</li>
<li>
<p>如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行，程序从try块后跟随的最后一个catch子句后面的语句继续执行下去</p>
</li>
<li>
<p>catch子句按其在try块后出现的顺序被检查，匹配的catch子句将捕获并按catch子句中的代码处理异常（或继续抛掷异常）</p>
</li>
<li>
<p>如果没有找到匹配，则缺省功能是调用abort终止程序。</p>
</li>
</ol>
</blockquote>
<h1 id="yi-chang-chu-li-ji-zhi-yu-fa">异常处理机制语法</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">异常发生第一现场，抛出异常</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">function</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="comment">//... ...</span></span><br><span class="line">          <span class="keyword">throw</span> 表达式;</span><br><span class="line">        <span class="comment">//... ...</span></span><br><span class="line">&#125;</span><br><span class="line">在需要关注异常的地方，捕捉异常</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//程序</span></span><br><span class="line">        <span class="built_in">function</span>();        把function至于<span class="keyword">try</span>中</span><br><span class="line">        <span class="comment">//程序</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(异常类型声明)&#123;        比如只写一个<span class="type">int</span></span><br><span class="line">        <span class="comment">//... 异常处理代码 ...</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(异常类型 形参)&#123;       形参将会取得抛出的值</span><br><span class="line">        <span class="comment">//... 异常处理代码 ...</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(...)&#123;               抛出的其它异常类型，可以接收任意类型</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">如果没有<span class="built_in">catch</span>(...)，并且没有<span class="keyword">catch</span>子句与抛出的异常类型匹配，程序会直接中断报错。</span><br></pre></td></tr></table></figure>
<p><strong>案例</strong>：</p>
<p>捕获除数为0的异常</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//try\catch的使用和switch\case的使用类似</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        z = <span class="built_in">division</span>(x, y);</span><br><span class="line">        cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未知异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//finally&#123;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Tips：</strong></p>
<p><strong>catch(…)能够捕获多种数据类型的异常对象，所以它提供给程序员一种对异常对象更好的控制手段，使开发的软件系统有很好的可靠性。因此一个比较有经验的程序员通常会这样组织编写它的代码模块</strong>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">try</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="comment">// 这里的程序代码完成真正复杂的计算工作，这些代码在执行过程中</span></span><br><span class="line">　　　　<span class="comment">// 有可能抛出DataType1、DataType2和DataType3类型的异常对象。</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType1&amp; d1)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType2&amp; d2)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType3&amp; d3)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">　　注意上面try block中可能抛出的DataType1、DataType2和DataType3三</span></span><br><span class="line"><span class="comment">　　种类型的异常对象在前面都已经有对应的catch block来处理。但为什么</span></span><br><span class="line"><span class="comment">　　还要在最后再定义一个catch(…) block呢？这就是为了有更好的安全性和</span></span><br><span class="line"><span class="comment">　　可靠性，避免上面的try block抛出了其它未考虑到的异常对象时导致的程</span></span><br><span class="line"><span class="comment">　　序出现意外崩溃的严重后果，而且这在用VC开发的系统上更特别有效，因</span></span><br><span class="line"><span class="comment">　　为catch(…)能捕获系统出现的异常，而系统异常往往令程序员头痛了，现</span></span><br><span class="line"><span class="comment">　　在系统一般都比较复杂，而且由很多人共同开发，一不小心就会导致一个</span></span><br><span class="line"><span class="comment">　　指针变量指向了其它非法区域，结果意外灾难不幸发生了。catch(…)为这种</span></span><br><span class="line"><span class="comment">　　潜在的隐患提供了一种有效的补救措施。</span></span><br><span class="line"><span class="comment">　　*********************************************************/</span></span><br><span class="line"> </span><br><span class="line">　　<span class="built_in">catch</span>(…)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ding-yi-xin-de-yi-chang">定义新的异常</h1>
<p><code>exception</code> 是所有C++异常的基类.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">exception</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">exception</span>() <span class="keyword">throw</span>();</span><br><span class="line">   <span class="built_in">exception</span>(<span class="type">const</span> exception&amp; rhs) <span class="keyword">throw</span>();</span><br><span class="line">   exception&amp; <span class="keyword">operator</span>=(<span class="type">const</span> exception&amp; rhs) <span class="built_in">throw</span>();</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">exception</span>() <span class="keyword">throw</span>();</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>您可以通过继承和重载 <code>exception</code> 类来定义新的异常。下面的实例演示了如何使用 <code>std::exception</code> 类来实现自己的异常：</p>
<p><strong><code>const throw()</code></strong> 不是函数，这个东西叫异常规格说明，表示 <code>what</code> 函数可以抛出异常的类型，类型说明放到 <strong><code>()</code></strong> 里，这里面没有类型，就是声明这个函数不抛出异常，通常函数不写后面的就表示函数可以抛出任何类型的异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MyException caught</span></span><br><span class="line"><span class="comment">C++ Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="biao-zhun-cheng-xu-ku-yi-chang-de-yong-fa">标准程序库异常的用法</h1>
<p><img src="/2022/05/22/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/20191103223242382.png" alt="20191103223242382"></p>
<p>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_alloc&amp; e) &#123;</span><br><span class="line">	std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="yi-chang-chu-li-zhong-de-gou-zao-yu-xi-gou">异常处理中的构造与析构</h1>
<ol>
<li>异常抛出之前构造异常对象</li>
<li>catch字句捕获异常时，将异常对象传递给catch形参</li>
<li>catch字句执行完成，调用异常对象的析构函数，异常对象自动销毁。</li>
</ol>
<p><strong>几个注意点：</strong></p>
<p><strong>1、栈展开</strong></p>
<p>栈展开指的是：当异常抛出后，匹配catch的过程。</p>
<p>​    抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。沿着<strong>函数的嵌套调用链向上查找</strong>，直到找到一个匹配的catch子句，或者找不到匹配的catch子句。</p>
<p>栈展开的时候，会通过析构函数或者是delete销毁局部对象(从开始匹配位置到确认匹配这一段中间位置的资源会被释放)</p>
<p><strong>2、析构函数应该从不抛出异常。</strong></p>
<p>如果析构函数中出现异常，那么就应该在析构函数<strong>内部</strong>将这个异常进行处理，而不是将异常抛出去。</p>
<ul>
<li>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</li>
<li>通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</li>
</ul>
<p><strong>3、构造函数可以抛出异常</strong></p>
<p>当构造函数内出现异常，可以选择将异常抛出，在栈展开的过程调用析构函数释放已申请的内存，也可以在内部将异常处理，手动调用delete释放</p>
<p><strong>4、catch捕获所有异常</strong></p>
<p>语法：在catch语句中，使用<strong>三个点（…）</strong>。即写成：catch (…)  这里三个点是“通配符”，类似 可变长形式参数</p>
<p><strong>5、在 C++11 中，声明一个函数不可以抛出任何异常使用关键字 <code>noexcept</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightThrow</span><span class="params">()</span></span>; <span class="comment">// could throw any exceptions.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doesNotThrow</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// does not throw any exceptions.</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>GO和C++语法上的主要差别</title>
    <url>/2022/05/22/GO%E5%92%8CC++%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B7%AE%E5%88%AB/</url>
    <content><![CDATA[<img src="/2022/05/22/GO%E5%92%8CC++%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B7%AE%E5%88%AB/1576218212309.png" alt="1576218212309" style="zoom:80%;">
<h1 id="gai-yao">概要</h1>
<p>GO语言是由Google在2012年正式发布的编程语言，在语法和特性上，GO和C++有很多相似之处，但也有很多不同点。本文就GO语言在语法上和C++的一些主要的差异点进行简单的描述。</p>
<p>Go 是一门简单、紧凑且通用的语言。而 C++ 是一门快速且复杂的通用编程语言。Go 和 C++ 都是静态类型语言且都有强大的社区。C++ 广泛用于各种应用，而 Go 主要用于 Web 后端。</p>
<p>Go 是专为现代多核处理器而设计的。Go 语言支持并发编程，这意味着它可以使用不同的线程同时运行多个处理过程，而不是同一时刻只运行一个任务。它还具有延迟垃圾回收功能，可以进行内存管理以防止内存泄漏。</p>
<ul>
<li>编译</li>
</ul>
<p>都可以静态编译，直接编译成二进制文件。目前，许多语言(比如Java,C#)都是基于运行时，能静态编译语言的不多，Go算一个。同时，都可以跨平台。</p>
<ul>
<li>内存管理</li>
</ul>
<p>在C++中，需要自己使用new和delete管理内存，尽管C++已经有了智能指针。但是有一些坑，不是那么好用。</p>
<p>Go虽是静态语言，但是自己管理内存，减轻了程序员的心智负担。这一点，非常重要。因为C++程序的崩溃，大多数时候都是内存问题，比如内存泄漏，非常难以解决。</p>
<ul>
<li>标准库</li>
</ul>
<p>一门语言开发效率高不高，它的标准库起着关键的作用。Go的标准库十分强大，常用的库几乎都有，开箱即用，十分顺手。C++的标准库里面的工具并不多，很多时候只能下载第三方库使用。不过，boost是一个著名的C++库，包含了大量的常用库。</p>
<ul>
<li>性能</li>
</ul>
<p>Go 相当快。其编译、静态类型以及高效的垃圾回收使其变得极其快。Go 也擅长内存管理；它有指针但没有引用。在速度方面，和 C++ 非常接近（以及 C 语言）。所有的时间都花在编码和编译上。因为 C++ 难编码，中级语言，更接近于机器码：当编译时，他更适合于机器码的嵌套。</p>
<p>C++ 也缺少那些让编码更容易但会给生成的程序增加阻力的特性。当提及运行时，C++ 轻量，精简且快速。</p>
<p>Go 配备了所有的能让你在编码过程中使生活更容易的零件和部件，因此，在运行时会慢一些。其中最大的一块是他的虽然很好但很慢的垃圾收集器。</p>
<ul>
<li><strong>并发编程</strong></li>
</ul>
<p>并发编程是Go语言的一大特色，可以轻松实现高并发，在语言层面就支持。C++只能调动系统API开启线程实现并发，语言层面并不支持。</p>
<ul>
<li>开发和调试难度</li>
</ul>
<p>C++的内存问题，很难排查和调试，比如内存越界，从程序崩溃的栈信息上可能就看不出来是什么问题，定位问题很难。Go进程中会启动Go自己的运行时，抛出的异常会指明错误信息，很容易能排查出问题。</p>
<h1 id="strong-dai-ma-ge-shi-strong"><strong>代码格式</strong></h1>
<p>GO语言要求代码的花括号<code>&#123;&#125;</code>必须采用统一的风格，即左花括号<code>&#123;</code>必须放在<strong>行尾</strong>而不能另起一行。</p>
<p>GO不需要在语句的最后增加分号<code>;</code>以表示语句结束。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b &#123;      <span class="comment">//花括号&#123;必须放在上一行的最后面</span></span><br><span class="line">    a += <span class="number">1</span>       <span class="comment">//语句后面不需要增加;号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="strong-chang-liang-he-bian-liang-strong"><strong>常量和变量</strong></h1>
<h2 id="strong-chang-liang-amp-bian-liang-sheng-ming-yu-fu-zhi-strong"><strong>常量&amp;变量声明与赋值</strong></h2>
<p>GO在进行变量声明时，需要在变量前加<code>var</code>关键字；但GO中的变量可以不定义直接赋值，此时GO会自己根据<code>:=</code>右侧的表达式计算出变量的类型。</p>
<p>同时，GO还支持多重赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">i = <span class="number">10</span></span><br><span class="line">str := <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">i1, str1 := <span class="number">10</span>, <span class="string">&quot;Hello World!&quot;</span>  <span class="comment">//多重赋值</span></span><br></pre></td></tr></table></figure>
<p>在定义常量常量时，和C++一样只需要在前面增加<code>const</code>关键字，并同时给常量赋以编译期可确定的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> i <span class="type">int</span> = <span class="number">2</span> &lt;&lt; <span class="number">5</span>  <span class="comment">//=号右侧的表达式必须可以在编译期确定</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    i1 <span class="type">int</span> = <span class="number">15</span></span><br><span class="line">    str = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO语言中有三个预定义的常量：<code>true</code>、<code>false</code>、<code>itoa</code>。<code>true</code>/<code>false</code>很好理解，<code>itoa</code>是一个很特殊和常量，它在一个<code>const</code>作用范围中，第一次出现时为0，后续每次出现都比上次的值大1，在GO中通常用于“枚举”（GO不支持枚举）定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    Monday = itoa       <span class="comment">//Monday = 0</span></span><br><span class="line">    Tuesday = itoa      <span class="comment">//Tuesday = 1</span></span><br><span class="line">    Wednesday = itoa    <span class="comment">//Wedesday = 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = itoa      <span class="comment">//下一个const作用域，x = 0</span></span><br></pre></td></tr></table></figure>
<h2 id="strong-ke-jian-xing-strong"><strong>可见性</strong></h2>
<p>GO语言中没有<code>private</code>/<code>protected</code>/<code>public</code>/<code>friend</code>关键字，可见性是通过成员的<strong>首字母是否大写</strong>决定的，并且仅支持包间的可见性定义，不支持类的可见性。</p>
<p>包中所有<strong>首字母大写</strong>开头的成员（对象、函数），表示<strong>包间可见</strong>，可以被其它包中的代码访问。但对于<strong>首字母小写</strong>开头的成员，则仅能被本包中的成员所访问（这相当于包内的所有成员间都加了friend声明）</p>
<h1 id="strong-tiao-jian-xuan-ze-he-xun-huan-strong"><strong>条件、选择和循环</strong></h1>
<h2 id="strong-tiao-jian-yu-ju-strong"><strong>条件语句</strong></h2>
<p>GO语言的条件语句中，条件不需要加括号<code>()</code>，并且支持初始化语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a := b; a == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="strong-xuan-ze-yu-ju-strong"><strong>选择语句</strong></h2>
<p>GO的选择语句中，不支持<code>break</code>关键字，因为GO的选择语句中，遇到符合条件的分支会<strong>自动跳出</strong>；如果想要继续向下执行，需要在<code>case</code>分支中增加<code>fallthrough</code>关键字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;0&quot;</span>)    <span class="comment">//i等于0或1时，执行完此打印语句后会退出</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span>        <span class="comment">//i等于2时，会继续向下执行</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在GO的switch后面可以不带表达式，此时在case中需要增加条件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="strong-xun-huan-yu-ju-strong"><strong>循环语句</strong></h2>
<p>GO不支持<code>while</code>和<code>do...while</code>形式的循环，仅支持<code>for</code>循环。在GO的<code>for</code>循环中可以通过多重赋值方式为多个变量赋值。对于多重循环，可以在最外层定义循环标签，并在内层循环中通过<code>break</code>关键字直接指定标签名，直接跳出外层循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">OutLoop:    <span class="comment">//定义循环标签</span></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//注意，在for循环中只能使用多重赋值</span></span><br><span class="line">        <span class="keyword">for</span> a, b := <span class="number">1</span>, <span class="number">5</span>; a &lt; b; a, b = a + <span class="number">2</span>, b + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> a == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> OutLoop    <span class="comment">//直接跳出循环标签所定义的外层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="strong-han-shu-strong"><strong>函数</strong></h1>
<p>在Golang语言中不支持函数的重载</p>
<p><strong>Golang不允许同一个文件里函数名不同</strong></p>
<p><strong>在Go中,函数本身也是一种数据类型,可以赋值给一个变量,该变量就是函数类型的变量,通过该变量实现对函数类型的调用</strong></p>
<h2 id="han-shu-ding-yi">函数定义</h2>
<p>Go 语言函数定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。<strong>可以有返回值，也可以没有</strong></li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<h3 id="return-yu-ju">return语句</h3>
<ol>
<li>Go 函数可以返回多个值，和python相似</li>
<li>如果返回多个值时，在接受时，希望忽略某个返回值，则使用<code>_</code>表示忽略</li>
<li>如果返回值只有一个，返回值类型列表可以不写<code>()</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;   <span class="comment">//两个返回值，此时一定要用（）括起来</span></span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以忽略返回值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func swap(x, y string) (string, string) &#123;   //两个返回值，此时一定要用（）括起来</span></span><br><span class="line"><span class="comment">   return y, x</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">   _, b := swap(&quot;Google&quot;, &quot;Runoob&quot;)    //注意看细节</span></span><br><span class="line"><span class="comment">   fmt.Println(a, b)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="strong-pu-tong-han-shu-strong"><strong>普通函数</strong></h2>
<p>在定义GO函数时，需要在前面增加<code>func</code>关键字，<code>func</code>后面紧随函数名，然后定义参数列表；GO语言是<strong>支持多返回值</strong>的，因此最后需要定义返回值列表。下面是两个int类型的除法函数示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数或返回值列表中，多个相同类型的可以通过逗号合并声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (ret <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//返回值会自动定义，在函数体内可直接赋值</span></span><br><span class="line">    err = errors.New(<span class="string">&quot;Cannot divide zero!&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>    <span class="comment">//在不指定时返回值时，将返回自动定义的对象（ret, err）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = a / b</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="strong-ke-bian-can-shu-strong"><strong>可变参数</strong></h2>
<p>GO和C++一样也支持可变参数，同样需要将可变参数放在所有参数的最后。GO的可变参数可以指定类型，也可以通过<code>interface&#123;&#125;</code>支持任意类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">varFunc1</span><span class="params">(argv ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">&#125;    <span class="comment">//只可以接受int类型的0到多个参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>, args...<span class="type">int</span>)</span></span> sum <span class="type">int</span>&#123;</span><br><span class="line">&#125;	<span class="comment">//可以接受int类型的1到多个参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">varFunc1</span><span class="params">(argv ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;   </span><br><span class="line">&#125;  <span class="comment">//可接受任意类型的可变参数</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ol>
<li>
<p>args是slice切片,通过args[index]可以访问到各个值</p>
</li>
<li>
<p>切片是一个动态的数组</p>
</li>
<li>
<p>如果一个函数的形参列表中有可变参数,那么把可变参数放在最后</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>, args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := n1</span><br><span class="line">	<span class="comment">//遍历args</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">		sum += args[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := sum(<span class="number">10</span>, <span class="number">234</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">34543</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">56</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="strong-ni-ming-han-shu-strong"><strong>匿名函数</strong></h2>
<p>Go 语言支持匿名函数，可作为闭包。匿名函数是一个&quot;内联&quot;语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<p>GO语言支持匿名函数，这一点是C++所不具备的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">	nextNumber := getSequence()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">	fmt.Println(nextNumber())</span><br><span class="line">	fmt.Println(nextNumber())</span><br><span class="line">	fmt.Println(nextNumber())</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">	nextNumber1 := getSequence()</span><br><span class="line">	fmt.Println(nextNumber1())</span><br><span class="line">	fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="jie-kou">接口</h1>
<p>Go 语言提供了另外一种数据类型即接口，<strong>它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。把所有方法全部实现了，叫做实现了接口</strong></p>
<p>接口类型可以定义一组方法，但是这些不需要实现，而且Interface<strong>不能包含任何的变量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">	method_name1 [return_type]</span><br><span class="line">	method_name2 [return_type]</span><br><span class="line">	method_name3 [return_type]</span><br><span class="line">	...</span><br><span class="line">	method_namen [return_type]</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 定义结构体 */</span></span><br><span class="line"> <span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/* variables */</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 实现接口方法 */</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_name1() [return_type] &#123;</span><br><span class="line">	<span class="comment">/* 方法实现 */</span></span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_namen() [return_type] &#123;</span><br><span class="line">	<span class="comment">/* 方法实现*/</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">	phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">	phone.call()</span><br><span class="line"></span><br><span class="line">	phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">	phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">I am Nokia, I can call you!</span></span><br><span class="line"><span class="comment">I am iPhone, I can call you!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="strong-cuo-wu-chu-li-strong"><strong>错误处理</strong></h1>
<p>GO语言通过error类型以及<code>defer</code>、<code>panic</code>、<code>recover</code>三个关键字，相对C++提供了更方便的错误处理。</p>
<ul>
<li><strong>error</strong>：</li>
</ul>
<p>GO的error实际是一个定义了<code>func Error() string</code>函数的接口。所有的error类型都必须实现<code>Error()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>因为GO支持多个返回值，因此可以通过在返回值中增加error类型，更方便开发人员判断调用是否成功，比如前面定义的Devide函数的调用可以按如下方式写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ret, err := Devide(a, b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在C++中要实现同样的功能，则需要函数抛出一个DevideZero异常，并在调用处捕获异常再处理；或是定义一个返回值并通过输出参数返回结果。而通过error进行处理则简单很多。</p>
<ul>
<li><strong>defer</strong></li>
</ul>
<p>使用C++的开发人员对C++中的内存、文件句柄等资源的释放的处理一定有很深的映像。<strong>在使用C++开发过程中，我们必须保证在函数退出或对象析构时进行正确的资源释放动作</strong>，而这在复杂的代码逻辑中往往是非常容易出错的地方。</p>
<p>GO语言通过<strong>defer</strong>关键字解决了开发人员的这个难题。开发人员只需要在申请了资源后立即通过defer关键字编写资源释放的代码，GO会保证在正确的时机释放资源（有点类似C++的finally）。比如下面的例子中，GO会保证在TestResource函数在退出前，调用到defer后面的代码以保证文件被关闭：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestResource</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(fn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果一个作用域内有多个defer，则在退出时会按先进后出的方式进行调用。因此在使用时应该尽量避免一个作用域内多个defer中的代码存在顺序要求，以避免出错。</p>
</blockquote>
<ul>
<li><strong>panic&amp;recover</strong></li>
</ul>
<p>panic和recover的函数原型如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>有点类似于C++中的抛出异常，在函数的执行过程中，如果panic被调用到则当前函数执行中止，此时将调用函数中走到过的defer代码，然后再依次向上级函数返回并调用这些函数的panic函数，直至当前goroutine中所有函数中止。</p>
<p>而recover函数通常用于在defer中用于判断函数是否是panic导致的退出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//说明是panic的情况，进行相应的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h1 id="strong-geng-feng-fu-de-nei-jian-lei-xing-strong"><strong>更丰富的内建类型</strong></h1>
<p>C++仅支持布尔、字符、数值内建类型，如果需要使用字符串、列表、字典，必须引入<strong>stl</strong>或其它库。</p>
<p>GO则将字符串、切片（slice）、字典、复数作为了原子类型支持。下面我们通过示例看一下GO对各种类型的支持：</p>
<p>golang的数组可以像python一样使用<code>range</code>遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> array&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>index : 数组下标</li>
<li>value 下标对应位置</li>
<li>array：数组名</li>
<li><strong>都是仅在for循环内部可见的局部变量</strong></li>
<li><strong>遍历数组时，如果不想使用index，可以使用<code>_</code>代替</strong></li>
</ol>
<h2 id="strong-zi-fu-chuan-string-strong"><strong>字符串（string）</strong></h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">str := <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">s = str</span><br></pre></td></tr></table></figure>
<h2 id="strong-qie-pian-slice-strong"><strong>切片（slice）</strong></h2>
<p>GO语言中的切片类似于stl中的vector，它实际包括了一个指向数组的指针，数组元素的个数，以及对应的内存存储空间。</p>
<ol>
<li>
<p>切片是数组的一个引用，那么切片是一个引用类型，这和数组是不一样的，函数中改变的会改变其值</p>
</li>
<li>
<p>切片的长度是可以变化的</p>
</li>
<li>
<p>切片的使用类似于数组，遍历和访问都是和数组一样的</p>
</li>
<li>
<p>切片的定义基本语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slicename [] <span class="keyword">type</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">slicename：切片名</span></span><br><span class="line"><span class="comment">type ：类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下面的示例展示了如何通过一个数组创建slice。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myArray := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">mySlice := myArray[:<span class="number">3</span>]</span><br><span class="line"><span class="comment">//通过len和cap函数，可以获取slice的长度和容量</span></span><br><span class="line">l, c := <span class="built_in">len</span>(mySlice), <span class="built_in">cap</span>(mySlice)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="type">int</span> = [...]<span class="type">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125; <span class="comment">//数组</span></span><br><span class="line">	slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(<span class="string">&quot;intarr=&quot;</span>, intArr)</span><br><span class="line">	fmt.Println(<span class="string">&quot;intarr的容量是 &quot;</span>, <span class="built_in">len</span>(intArr))</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice 的元素是 &quot;</span>, slice)</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice 的容量是&quot;</span>, <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice 的元素个数为&quot;</span>, <span class="built_in">len</span>(slice))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">intarr= [11 22 33 44 55]</span></span><br><span class="line"><span class="comment">intarr的容量是  5</span></span><br><span class="line"><span class="comment">slice 的元素是  [22 33]</span></span><br><span class="line"><span class="comment">slice 的容量是 4</span></span><br><span class="line"><span class="comment">slice 的元素个数为 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>也可以通过<code>make</code>函数创建指定类型、长度和容量的slice：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个int类型的slice，初始长度为3，但容量为5</span></span><br><span class="line">myArray := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>slice 是切片名称</li>
<li>intArr[1:3] 表示slice引用数组第二个元素到下标</li>
<li><strong>引用intArr数组的起始下标为1，终止下标为3，但是不包含3</strong></li>
<li>切片的容量cap是可变的，这样可以节约空间</li>
<li><strong>此时改变数组的值，slice 的值也会发生变化（引用）</strong></li>
</ol>
<p><strong>切片在内存中形式</strong></p>
<p><strong>在内存里，可以理解为slic是由三个部分组成的</strong></p>
<ol>
<li>第一个位置记录的是数组的地址，是引用类型</li>
<li>第二个记录了slic本身的长度</li>
<li>第三个记录的是slic容量的大小</li>
</ol>
<p>可以理解为slic是一个引用类型（本身也是有个地址）slic从底层来说其实就是一个数据结构，是struct结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">	ptr *[<span class="number">2</span>]<span class="type">int</span></span><br><span class="line">	<span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>append() 和 copy() 函数</strong></p>
<ul>
<li>append动态追加</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;</span><br><span class="line">slice3 = <span class="built_in">append</span>(slice, <span class="number">400</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment">/*slice4则是一个新的空间，slice3被回收，如果是slice3，则在原来的空间扩容*/</span></span><br><span class="line">fmt.Println(<span class="string">&quot;slice&quot;</span>, slice)</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</strong></li>
<li><strong>使用append时Go底层创建一个新的数组newArr安装扩容后大小</strong></li>
<li><strong>将slice原来包含的元素拷贝到新的数组，newArr是在底层维护的，程序员不可见</strong></li>
</ol>
<ul>
<li>copy内置函数拷贝</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice4 []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice5 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">copy</span>(slice5, slice4) <span class="comment">//将切片slice4拷贝为slice5</span></span><br><span class="line"></span><br><span class="line">fmt.Println(slice4) <span class="comment">//1,2,3,4,5</span></span><br><span class="line">fmt.Println(slice5) <span class="comment">//1,2,3,4,5,0,0,0,0,0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果修改slice5的值，slice4不变，他们之间的数据空间是独立的</li>
<li>默认情况下，使用make后，多余的空间默认为0</li>
</ol>
<p><strong>当使用拷贝的时候，如果当前切片容量不够怎么办，会报错吗？</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;a=&quot;</span>, a)</span><br><span class="line">	fmt.Println(slice) <span class="comment">//0</span></span><br><span class="line">	<span class="built_in">copy</span>(slice, a)</span><br><span class="line">	fmt.Println(slice) <span class="comment">//不会报错，而且赋予的是第一个元素的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a= [1 2 3 4 5]</span></span><br><span class="line"><span class="comment">[0]</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="strong-zi-dian-map-strong"><strong>字典（map）</strong></h2>
<p>在Go中定义字典类型以<code>map[KeyType]ValueType</code>的形式定义，示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dict <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>) <span class="comment">//构造了下string:int类型的map，容量为100</span></span><br><span class="line">dict[<span class="string">&quot;int_1&quot;</span>] = <span class="number">1</span></span><br><span class="line">v, ok := dict[<span class="string">&quot;int_1&quot;</span>] <span class="comment">//通过判断第2个返回值是否为true，可以判断数据是否存在</span></span><br></pre></td></tr></table></figure>
<h2 id="strong-fu-shu-complex-64-complex-128-strong"><strong>复数（complex64/complex128）</strong></h2>
<p>除了以上常见的数据类型，Go还支持复数类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="type">complex64</span></span><br><span class="line">z = <span class="number">10</span> + <span class="number">20i</span>        <span class="comment">//即10 + 20i</span></span><br><span class="line">a = <span class="built_in">real</span>(z)         <span class="comment">//real获取复数的实部</span></span><br><span class="line">b = <span class="built_in">imag</span>(z)         <span class="comment">//imag获取复数的虚部 </span></span><br></pre></td></tr></table></figure>
<p>除了以上类型，GO还支持管道channel、unicode字符rune、错误类型error、指针pointer。</p>
<hr>
<h1 id="strong-lei-xing-xi-tong-strong"><strong>类型系统</strong></h1>
<p>除了内建类型之后，GO也支持用户自定义类型，比如struct、interface，但在语法上有一些差异，比如下面的示例是GO的struct和interface的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestItf <span class="keyword">interface</span> &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但GO的struct和interface与C++存在几点显著的不同：</p>
<ol>
<li>不支持继承，只能通过组合实现继承</li>
<li>可以给任意类型增加方法</li>
<li>类不需要显式指定实现interface</li>
<li>对象可以在多个具有相同接口的interface间转换</li>
</ol>
<p>通过以下的示例可以更好的理解以上几点差异：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将内建类型int定义Integer</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span>           </span><br><span class="line"><span class="comment">//为Integer增加Add方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span>Add(b Integer) Integer&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">struct</span> &#123;</span><br><span class="line">    I Integer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Father并没有显式实现IReader接口，但通过实现了Read函数就相当于是IReader的实例了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Father)</span></span>Read() <span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Father::I = &quot;</span>, f.I)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Father&#x27;s Read&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">    Father    <span class="comment">//通过匿名组合了Father，Child自动“继承”了I成员和Func方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IStream <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj IReader</span><br><span class="line"><span class="keyword">var</span> is IStream</span><br><span class="line">c := &amp;Child&#123;&#125;</span><br><span class="line">obj = c        <span class="comment">//Child是IReader的实例，因为c通过组合继承了Father实现的Read方法</span></span><br><span class="line">is = obj       <span class="comment">//IReader因为和IStream有相同的接口定义，因此可以互相转换</span></span><br></pre></td></tr></table></figure>
<h1 id="go-bing-fa">Go并发</h1>
<p>Go 语言支持并发，我们只需要通过 <code>go</code> 关键字来开启 goroutine 即可。</p>
<p>goroutine 是<strong>轻量级线程</strong>，goroutine 的调度是由 Golang 运行时进行管理的。</p>
<p>goroutine 语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名( 参数列表 )</span><br></pre></td></tr></table></figure>
<p>Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 <strong>同一个程序中的所有 goroutine 共享同一个地址空间</strong>。</p>
<p><strong>案例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">	say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行以上代码，你会看到输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行。</p>
<hr>
<h1 id="tong-dao">通道</h1>
<h2 id="gai-nian">概念</h2>
<p>通道（channel）是用来传递数据的一个数据结构。</p>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 <code>&lt;-</code> 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure>
<p>声明一个通道很简单，我们使用<code>chan</code>关键字即可，通道在使用前必须先创建：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。</p>
<p>以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- sum <span class="comment">// 把 sum 发送到通道 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">	<span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">	x, y := &lt;-c, &lt;-c <span class="comment">// 从通道 c 中接收</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-5 17 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="tong-dao-huan-chong-qu">通道缓冲区</h2>
<p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于<strong>异步状态</strong>，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<p><strong>注意</strong>：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们定义了一个可以存储整数类型的带缓冲通道</span></span><br><span class="line">	<span class="comment">// 缓冲区大小为2</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span></span><br><span class="line">	<span class="comment">// 而不用立刻需要去同步读取数据</span></span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	ch &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取这两个数据</span></span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="go-bian-li-tong-dao-yu-guan-bi-tong-dao">Go 遍历通道与关闭通道</h2>
<p>Go 通过 <code>range</code> 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>
<p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 <code>close()</code> 函数来关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		c &lt;- x</span><br><span class="line">		x, y = y, x+y</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">	<span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">	<span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">	<span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">	<span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">34</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="yao-dian">要点</h2>
<ol>
<li>
<p>goroutine 是 golang 中在语言级别实现的轻量级线程，仅仅利用 go 就能立刻起一个新线程。多线程会引入线程之间的同步问题，在 golang 中可以使用 channel 作为同步的工具。</p>
<p>通过 channel 可以实现两个 goroutine 之间的通信。</p>
<p>向 channel 传入数据， <code>CHAN &lt;- DATA</code> ， CHAN 指的是目的 channel 即收集数据的一方， DATA 则是要传的数据。</p>
<p>从 channel 读取数据， <code>DATA := &lt;-CHAN</code> ，和向 channel 传入数据相反，在数据输送箭头的右侧的是 channel，形象地展现了数据从隧道流出到变量里。</p>
</li>
<li>
<p>Channel 是可以控制读写权限的 具体如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义只读的channel</span></span><br><span class="line">read_only := <span class="built_in">make</span> (&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义只写的channel</span></span><br><span class="line">write_only := <span class="built_in">make</span> (<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//可同时读写</span></span><br><span class="line">read_write := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>定义只读和只写的channel意义不大，一般用于在参数传递中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> send(c)</span><br><span class="line">	<span class="keyword">go</span> recv(c)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能向chan里写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		c &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能取channel中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>GO</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>Git及相关操作</title>
    <url>/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/1576218250849.png" alt="1576218250849" style="zoom: 67%;">
<h1 id="ban-ben-kong-zhi">版本控制</h1>
<blockquote>
<p>版本控制是一种在开发过程中用于管理我们对文件、目录工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
</blockquote>
<blockquote>
<p><strong>版本控制分类</strong></p>
</blockquote>
<ol>
<li>
<p><strong>本地版本控制</strong></p>
<p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人使用，如RCS。</p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506144248059.png" alt="image-20220506144248059" style="zoom:80%;">
</li>
<li>
<p><strong>集中版本控制</strong></p>
<p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506144736888.png" alt="image-20220506144736888" style="zoom:80%;">
<p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS。</p>
</li>
<li>
<p><strong>分布式版本控制</strong></p>
<p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>
<p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506145700293.png" alt="image-20220506145700293" style="zoom:80%;">
</li>
</ol>
<blockquote>
<p>Git和SVN最主要的区别</p>
</blockquote>
<p><strong>SVN</strong>是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>
<p><strong>Git</strong>是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git是目前世界上最先进的分布式版本控制系统。</p>
<p>==Git是目前世界上最先进的分布式版本控制系统==</p>
<h1 id="git-huan-jing-pei-zhi">Git环境配置</h1>
<blockquote>
<p>软件下载</p>
</blockquote>
<p>打开 git官网： <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p>
<p>所有东西下载慢的话就可以去找镜像！</p>
<p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506151614414.png" alt="image-20220506151614414" style="zoom:50%;">
<p>下载对应的版本即可安装！</p>
<p>安装：无脑下一步即可！安装完毕就可以使用了！</p>
<blockquote>
<p>启动Git</p>
</blockquote>
<p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p>
<p>**Git Bash：**Unix与Linux风格的命令行，使用最多，推荐最多</p>
<p>**Git CMD：**Windows风格的命令行</p>
<p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p>
<blockquote>
<p>常用的Linux命令</p>
</blockquote>
<p>1）cd : 改变目录。</p>
<p>2）cd . . 回退到上一个目录，直接cd进入默认目录</p>
<p>3）pwd : 显示当前所在的目录路径。</p>
<p>4）ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p>
<p>5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p>
<p>6）rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p>
<p>7）mkdir:  新建一个目录,就是新建一个文件夹。</p>
<p>8）rm -r :  删除一个文件夹, rm -r src 删除src目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！</span><br></pre></td></tr></table></figure>
<p>9）mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p>
<p>10）reset 重新初始化终端/清屏。</p>
<p>11）clear 清屏。</p>
<p>12）history 查看命令历史。</p>
<p>13）help 帮助。</p>
<p>14）exit 退出。</p>
<p>15）#表示注释</p>
<blockquote>
<p>Git配置</p>
</blockquote>
<p>查看配置 <code>git config -l</code></p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506160111412.png" alt="image-20220506160111412" style="zoom:80%;">
<p>查看不同级别的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看系统config</span></span><br><span class="line">git config --system --list</span><br><span class="line">　　</span><br><span class="line"><span class="comment">#查看当前用户（global）配置</span></span><br><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure>
<p><strong>Git相关的配置文件：</strong></p>
<p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   --system 系统级</p>
<p>2）、C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  --global 全局</p>
<blockquote>
<p>设置用户名与邮箱（用户标识，必要）</p>
</blockquote>
<p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;user&quot;</span>  <span class="comment">#名称</span></span><br><span class="line">git config --global user.email user@XXX.com   <span class="comment">#邮箱</span></span><br></pre></td></tr></table></figure>
<p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p>
<p><img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506161314084.png" alt="image-20220506161314084"></p>
<h1 id="git-ji-ben-li-lun">Git基本理论</h1>
<blockquote>
<p>三个区域</p>
</blockquote>
<p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/3214.png" alt="3214" style="zoom:80%;">
<ul>
<li>Workspace：<strong>工作区</strong>，就是你平时存放项目代码的地方</li>
<li>Index / Stage：<strong>暂存区</strong>，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository：<strong>仓库区</strong>（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote：<strong>远程仓库</strong>，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506210730715.png" alt="image-20220506210730715" style="zoom: 50%;">
<ul>
<li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li>
<li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li>
<li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li>
<li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li>
<li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li>
<li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li>
</ul>
<blockquote>
<p><strong>工作流程</strong></p>
</blockquote>
<p>git的工作流程一般是这样的：</p>
<p>１、在工作目录中添加、修改文件；</p>
<p>２、将需要进行版本管理的文件放入暂存区域；</p>
<p>３、将暂存区域的文件提交到git仓库。</p>
<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/640.jpg" alt="640" style="zoom: 67%;">
<h1 id="git-xiang-mu-da-jian">Git项目搭建</h1>
<blockquote>
<p>创建工作目录与常用指令</p>
</blockquote>
<p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>
<p>日常使用只要记住下图6个命令：</p>
<img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/640.png" alt="640" style="zoom:80%;">
<blockquote>
<p>本地仓库搭建</p>
</blockquote>
<p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>
<p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p>
<blockquote>
<p>克隆远程仓库</p>
</blockquote>
<p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>
<p>2、去 gitee 或者 github 上克隆一个测试！</p>
<h1 id="git-wen-jian-cao-zuo">Git文件操作</h1>
<blockquote>
<p>文件的四种状态</p>
</blockquote>
<p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li>
<li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li>
<li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li>
<li><strong>Staged</strong>: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>
</ul>
<blockquote>
<p>查看文件状态</p>
</blockquote>
<p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看指定文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># git add .                  添加所有文件到暂存区</span></span><br><span class="line"><span class="comment"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>忽略文件</p>
</blockquote>
<p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>
<p>在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则：</p>
<ol>
<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       #忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure>
<h1 id="yuan-cheng-cang-ku">远程仓库</h1>
<p>远程仓库可以选用Github或者Gitee等常用仓库，设置本机绑定SSH公钥，实现免密码登录等操作本处不做详细介绍。</p>
<p>1、新建项目，绑定git。</p>
<p>2、修改文件，使用IDEA操作git。</p>
<ul>
<li>
<p>添加到暂存区</p>
</li>
<li>
<p>commit 提交</p>
</li>
<li>
<p>push到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">#如果本地分支名与远程分支名相同，则可以省略冒号：</span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line">#eg:以下命令将本地的 master 分支推送到 origin 主机的 master 分支</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3、提交测试</p>
<h1 id="shuo-ming-git-fen-zhi">说明：GIT分支</h1>
<p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p>
<p><img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/235235.png" alt="235235"></p>
<p><img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/54675.png" alt="54675"></p>
<p>git分支中常用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
<p>IDEA中操作</p>
<p><img src="/2022/05/07/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/235423.png" alt="235423"></p>
<p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p>
<p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用教程及MarkDown语法</title>
    <url>/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/girl-16518503155441.jpg" alt="girl"></p>
<h1 id="markdown-yu-typora-jie-shao">Markdown与Typora介绍</h1>
<h2 id="markdown-jie-shao">Markdown介绍</h2>
<blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 .md, .markdown</p>
</blockquote>
<h2 id="typora-jie-shao-yu-xia-zai">Typora介绍与下载</h2>
<p>Typora编辑器让人们能更简单地用Markdown语言书写文字，解决了使用传统的Markdown编辑器写文的痛点，并且界面简洁优美，实现了实时预览等功能。</p>
<p>Typora官网： <a href="https://typora.io/">https://typora.io/</a></p>
<h1 id="markdown-yu-fa">Markdown语法</h1>
<h2 id="biao-ti">标题</h2>
<p>使用 <code>#</code> 可以表示标题，一级标题对应一个 <code>#</code> ，二级标题对应两个 <code>#</code> 号，最多至六级标题。在Typora中，<code>#</code> 后要紧接着一个空格才能表示标题，否则就是普通字符。</p>
<p>在Typora中，也可以使用快捷键<strong>Ctrl+1</strong>（2，3，4，5，6）表示相对应的标题。<strong>Ctrl+0</strong>表示段落。标题快捷键信息可在菜单栏中的段落选项下查看。</p>
<h2 id="zi-ti">字体</h2>
<ul>
<li>
<p>用一对星号括住的文本表示斜体文本，如：<code>*</code>要变斜体的文本<code>*</code>，<em>斜体文本</em> ；</p>
</li>
<li>
<p>也可以用一对下划线括住文本来表示斜体文本，如：<code>_</code>要变斜体的文本<code>_</code>，<em>斜体文本</em> ；</p>
</li>
</ul>
<p>也可以使用Typora的快捷键<strong>Ctrl+I</strong>来表示斜体文本。</p>
<ul>
<li>
<p>用一对<code>**</code>括住的文本表示粗体文本，如：<code>**</code>要变粗体的文本<code>**</code>，<strong>粗体文本</strong>；</p>
</li>
<li>
<p>也可以用一对<code>__</code>括住的文本来表示粗体文本，如：<code>__</code>要变粗体的文本<code>__</code>，<strong>粗体文本</strong>；</p>
</li>
</ul>
<p>也可以使用Typora的快捷键<strong>Ctrl+B</strong>来表示粗体文本。</p>
<p>用一对<code>***</code>括住的文本表示粗斜体文本，如：<code>***</code>要变粗斜体的文本<code>***</code>，<em><strong>粗斜体文本</strong></em>；<br>
也可以用一对<code>___</code>括住的文本来表示粗斜体文本，如：<code>___</code>要变粗斜体的文本<code>___</code>，<em><strong>粗斜体文本</strong></em></p>
<h2 id="ge-chong-xian">各种线</h2>
<ul>
<li>分割线，可以使用<strong>三个及以上</strong>的 <code>+</code> 号或 <code>*</code> 号或 <code>-</code> 来表示一条分割线；</li>
</ul>
<hr>
<ul>
<li>删除线，可以使用一对<code>~~</code>括住的文本来表示删除文本，如：<code>~~</code>要加删除线的文本<code>~~</code>，<s>删除文本</s>；在Typora中，也可以使用快捷键<strong>Alt+Shift+5</strong>来加删除线，语法相同，<s>删除线</s>。</li>
<li>下划线，可以使用HTML的标签<code>&lt;u&gt;</code>和<code>&lt;/u&gt;</code>表示增加下划线的文本，如：<code>&lt;u&gt;</code>要增加下划线的文本<code>&lt;/u&gt;</code>，<u>下划线</u>；在Typora中，也可以使用快捷键<strong>Ctrl+U</strong>来增加下划线，语法也是相同的，<u>下划线</u>。</li>
</ul>
<h2 id="lie-biao">列表</h2>
<p><strong>无序列表</strong></p>
<p>可以使用<code>*</code>，<code>+</code>或<code>-</code>标记符号来表示无序列表项，记住要在标记符号后<strong>添加一个空格</strong>，语法显示如下：</p>
<p>在Typora中可以使用快捷键<strong>Ctrl + Shift + ]</strong> 、<strong>Ctrl + Shift + [</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br></pre></td></tr></table></figure>
<h2 id="strong-you-xu-lie-biao-strong"><strong>有序列表</strong></h2>
<p>可以使用<strong>数字加上<code>.</code>再加上空格</strong>来表示有序列表，语法如下：</p>
<p>在Typora中可以使用快捷键<strong>Ctrl + Shift + [</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">3. 第二项</span><br><span class="line">10. 第三项</span><br></pre></td></tr></table></figure>
<p><strong>嵌套列表</strong></p>
<p>首先使用<code>*</code>、<code>+</code>或<code>-</code>进入列表，然后回车换行，会发现系统自动生成列表第二项，此时按下<strong>Tab</strong>键，列表第二项变为第一项的子列表。<strong>按回车退出当前列表</strong>。可以在无序列表中嵌套有序列表, 也可以在有序列表中嵌套无序列表。</p>
<ol>
<li>一级
<ol>
<li>一一级</li>
<li>一二级
<ul>
<li>一二一级</li>
<li>一二二级</li>
</ul>
</li>
<li>一三级</li>
</ol>
</li>
<li>二级</li>
</ol>
<p>快捷键<strong>Shift + tab</strong> ——返回上一级列表</p>
<h2 id="qu-kuai">区块</h2>
<p>当我们想要引用别人的文章内容时，可以将其放在区块内。</p>
<p>可以使用<code>&gt;</code>加空格来表示区块。</p>
<blockquote>
<p>一级区块</p>
<blockquote>
<p>二级区块</p>
<blockquote>
<p>三级区块</p>
</blockquote>
<p>二级区块</p>
</blockquote>
</blockquote>
<p>要退出区块，同样使用<code>Enter</code>键即可</p>
<h2 id="dai-ma">代码</h2>
<p>如果是一行代码，可以使用段内代码块来表示，用一对 <strong>`</strong>（数字1旁边的符号）括住代码。</p>
<p>比如<code>printf(&quot;Hello World!&quot;)</code></p>
<p>如果是代码段，那么可以使用<strong>三个 ` 加Enter/空格+编程语言</strong>来表示。使用快捷键<strong>ctrl + shift + k</strong>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lian-jie">链接</h2>
<p>链接的使用方式有两种语法，如下：</p>
<p><code>[</code>链接文字<code>]</code> <code>(</code>链接地址<code>)</code><br>
或<br>
<code>[</code>链接文字<code>]</code> <code>()</code></p>
<p>示例如下：按住<strong>Ctrl+鼠标左键</strong>点击访问。</p>
<p><a href="https://www.baidu.com/">百度</a><br>
<a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<p>链接除了可以打开相应的网页外，还可以<strong>打开本地文件</strong>，使用方式类似，不过链接地址需要使用本地文件的地址，相对地址、绝对地址均可：</p>
<p><code>[</code>打开LinkTest.md文档<code>]</code> <code>(</code>./LinkTest.md<code>)</code></p>
<p>我们也可以使用链接来实现<strong>页内跳转</strong>，语法为：</p>
<p><code>[</code>链接文字<code>]</code> <code>(</code>#标题文字<code>)</code></p>
<p>eg: <a href="#Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E5%8F%8AMarkDown%E8%AF%AD%E6%B3%95">跳到首页</a></p>
<h2 id="tu-pian">图片</h2>
<p>我们也可以在Markdown文档中插入图片，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先一个感叹号</li>
<li>然后中括号里面写属性文本</li>
<li>小括号里面写图片地址，后可接标题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![本地png图片PictureTest.png](./img/PictureTest.png)</span><br><span class="line"></span><br><span class="line">![本地jpg图片](./img/PictureTest.jpg)</span><br><span class="line"></span><br><span class="line">![网络图片](http://static.runoob.com/images/runoob-logo.png &quot;菜鸟教程&quot;)</span><br></pre></td></tr></table></figure>
<p>在Typora中，也可以直接使用<code>Ctrl+C</code>，<code>Ctrl+V</code>来直接进行复制粘贴图片，但是，由于Markdown是需要图片的地址的，所以需要简单设置一下Typora。</p>
<p>点击文件 --&gt; 偏好设置 --&gt; 图像，如下：</p>
<p><img src="/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjYxMjUx,size_16,color_FFFFFF,t_70-16518503155442.png" alt="img"></p>
<p>可以自行设置选择将图片复制到哪个文件夹。</p>
<p><img src="/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/20191108173139695-16518503155444.png" alt="img"></p>
<p>这里选择复制到指定路径，然后在下面一栏中填写./img，表示将图片复制到你正在编辑的文档同一级的img文件夹下。在下面的选项中，勾选第一、二、三项。正因为勾选了第二项，所以当我们在插入网络图片时，Typora会自动帮我们将网络图片下载到指定的路径下，前面的&quot;菜鸟教程&quot;图片便是如此。</p>
<p>由于Markdown的特殊语法，故经常会出现图片加载失败的情况，很大的可能就是因为在指定的路径上找不到相应的图片，当然，有时候也是由于Typora的原因，重启Typora即可</p>
<h2 id="yan-se-zi-ti">颜色字体</h2>
<p>替换对应颜色代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$\color&#123;#FF3030&#125;&#123;red&#125;$</span><br><span class="line"></span><br><span class="line">$\color&#123;#0000CD&#125;&#123;blue&#125;$</span><br><span class="line"></span><br><span class="line">$\color&#123;#33ff66&#125;&#123;green&#125;$</span><br><span class="line"></span><br><span class="line">$\color&#123;#ffff00&#125;&#123;yellow&#125;$</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/image-20220506232014009.png" alt="image-20220506232014009"></p>
<h2 id="biao-ge">表格</h2>
<p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">|---|---|----|</span><br><span class="line">|单元格|单元格|单元格|</span><br><span class="line">|单元格|单元格|单元格|</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody>
<tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
<p>我们可以设置对齐方式：</p>
<ul>
<li><code>:-</code>表示左对齐</li>
<li><code>-:</code>表示右对齐</li>
<li><code>:-:</code>表示中间对齐</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|左对齐|右对齐|中间对齐|</span><br><span class="line">|:---|---:|:----:|</span><br><span class="line">|单元格|单元格|单元格|</span><br><span class="line">|单元格|单元格|单元格|</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:center">中间对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
<p>在Typora中，我们可以使用快捷键<strong>Ctrl+T</strong>来插入表格，并选择行列，当选中表格某一单元格时，可以在表格左上角手动设置对齐方式，右上角选择更多操作。</p>
<h1 id="typora-yu-shu-xue-gong-shi">Typora与数学公式</h1>
<h2 id="ru-he-cha-ru-shu-xue-gong-shi">如何插入数学公式</h2>
<p>在Typora中，有两种方法插入数学公式，语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种方法：$数学公式$</span><br><span class="line">第二种方法：</span><br><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>第一种方法表示插入行内公式（内联公式），即可以将公式插入到一行中，比如$1 + 2 = 3$ 这样的公式。</p>
<p>第二种方法表示插入行间公式（外联公式），即可以将公式插入到行与行之间，单独占据一行或者数行的空间，并且居中放置。<br>
$$<br>
1+2=3<br>
$$<br>
如果要在行间公式内换行，在换行的位置使用<code>\\</code></p>
<p>常用符号、上下标、根号、括号、运算符等此处不做详细介绍</p>
<h1 id="typora-yu-html">Typora与HTML</h1>
<h2 id="gai-bian-zi-ti-yan-se-ji-da-xiao">改变字体颜色及大小</h2>
<p>我们可以使用<code>&lt;font&gt; &lt;/font&gt;</code>标签来改变字体的颜色及大小，如：</p>
<p>属性<code>size</code>表示字体大小，<code>color</code>表示颜色。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font size=3 color=&quot;red&quot;&gt;字体颜色为红色，大小为3&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font size=4 color=&quot;blue&quot;&gt;字体颜色为蓝色，大小为4&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font size=6 color=&quot;violet&quot;&gt;字体颜色为紫罗兰，大小为6&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p><font size="3" color="red">字体颜色为红色，大小为3</font></p>
<p><font size="4" color="blue">字体颜色为蓝色，大小为4</font></p>
<p><font size="6" color="violet">字体颜色为紫罗兰，大小为6</font></p>
<h2 id="gai-bian-dui-qi-fang-shi">改变对齐方式</h2>
<p>我们可以改变字体的对齐方式，用标签<code>&lt;p&gt; &lt;/p&gt;</code>加上属性<code>align</code>，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p align=&quot;left&quot;&gt;左对齐&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;center&quot;&gt;中间对齐&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p align="left">左对齐</p>
<p align="left">左对齐</p>
<p align="center">中间对齐</p>
<p align="right">右对齐</p>
<h2 id="cha-ru-tu-xiang">插入图像</h2>
<p>因为CSDN不支持使用img标签修改图像，所以下面的结果都不是准确的。大家可以自己在Typora中测试。<br>
我们可以通过标签<code>&lt;img src=url /&gt;</code>来插入图片，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;img/3.jpg&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以改变<code>&lt;img&gt;</code>标签的属性，来改变图片的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;img/3.jpg&quot; width=100 height=100/&gt;</span><br></pre></td></tr></table></figure>
<img src="/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/3-16518503155443.jpg" width="100" height="100/">
<p>我们可以改变<code>&lt;img&gt;</code>标签的属性，来改变图片的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;img/3.jpg&quot; width=30 height=30 style=&quot;float:left&quot;/&gt;图片在左边</span><br><span class="line">&lt;img src=&quot;img/3.jpg&quot; width=30 height=30 style=&quot;float:right&quot;/&gt;图片在右边</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/3-16518503155443.jpg" width="100" height="100" style="float:left">图片在左边</p>
<img src="/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/3-16518503155443.jpg" width="100" height="100" style="float:right">
<p>图片在右边</p>
<h1 id="kuo-zhan-yong-fa">扩展用法</h1>
<h2 id="cha-ru-emoji-biao-qing">插入emoji表情</h2>
<p>我们可以使用<code>:emoji:</code>的语法来插入表情，比如：</p>
<p>:happy:的语法为<code>:happy:</code></p>
<p>🦀的语法为<code>:crab:</code></p>
<p>🐴的语法为<code>:horse:</code></p>
<h2 id="cha-ru-mu-lu">插入目录</h2>
<p>当我们为使用标题将文分章节后，可以在输入<code>[toc]</code>命令的地方自动根据标题生成目录。</p>
<h2 id="wen-ben-gao-liang">文本高亮</h2>
<p>在Typora中，可以用一对<code>==</code>将要高亮的文本括起来，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==要高亮的文本==</span><br><span class="line">==背景会用黄色填充==</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2022/05/07/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/image-20220506233054585.png" alt="image-20220506233054585"></p>
<p>这个功能可在偏好设置 --&gt; Markdown扩展语法中设置。</p>
]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>关于__pycache__文件夹</title>
    <url>/2022/05/27/%E5%85%B3%E4%BA%8E__pycache__%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>最近在查看某个py程序时，发现很多模块下都存在一个名字为<code>__pycache__</code> 文件夹，如下图所示。</p>
<p><img src="/2022/05/27/%E5%85%B3%E4%BA%8E__pycache__%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220526200618937.png" alt="image-20220526200618937"></p>
<p>查阅相关资料现总结如下：</p>
<blockquote>
<p><code>__pycache__</code> 文件夹是 Python 解释器自动生成的，用来存放编译的字节码</p>
</blockquote>
<p>先大概了解一下python基本运行机制。Python程序运行时不需要编译成二进制代码，而直接从源码运行程序，简单来说是，Python解释器将源码转换为字节码，然后再由解释器来执行这些字节码。</p>
<p><strong>解释器的具体工作：</strong></p>
<ol>
<li>完成模块的加载和链接;</li>
<li>将源代码编译为<code>PyCodeObject</code>对象（即字节码），写入内存中，供CPU读取；</li>
<li>从内存中读取并执行，结束后将<code>PyCodeObject</code>写回硬盘当中，也就是复制到<code>.pyc</code>或<code>.pyo</code>文件中，以保存当前目录下所有脚本的字节码文件</li>
</ol>
<p>之后若再次执行该脚本，它先检查[<strong>本地是否有上述字节码文件</strong>]和[<strong>该字节码文件的修改时间是否在其源文件之后</strong>]，是就直接执行，否则重复上述步骤。</p>
<p>意义在于：第一次执行代码时，python解释器已经把编译的字节码放在了<code>__pycache__</code>文件夹中，这样以后再运行的话，如果被调用模块未发生改变，那就直接跳过编译这一步，直接去<code>__pycache__</code>文件夹中去运行相关的<code>*.pyc</code>文件，大大缩短了项目运行前的准备时间。</p>
<p><strong>注</strong>：</p>
<p><strong><code>.pyc</code>文件类型</strong></p>
<p>当你导入一个模块时，解释器会自动生成<code>.pyc</code>文件，这样会节省下次导入的时间。注意，使用<code>.pyc</code>文件只是加速程序加载的时间，而不是加速程序执行的时间。</p>
<p>注意：因为<code>.pyc</code>文件是平台不相关的，所以可以在不同架构的机器上使用同一个<code>.pyc</code>文件。然而，如果开发者在他们的系统上使用不同的时钟时间，在生成<code>.pyc</code>文件的时候同时生成时间戳，将来其他的开发者读取这个时间戳，这可能导致对源码进行修改的时候不会修改字节码，这是一个不容易被发现的严重的bug。最好的方式就是把在进行版本控制的时候忽略<code>.pyc</code>文件。</p>
<blockquote>
<p>文件夹下所产生的文件<code>*.pyc</code>没有必要提交到版本管理仓库上，可以通过在本地 Project 中的 <strong>.gitignore</strong>文件中增加 <code>*.pyc</code>.</p>
</blockquote>
<p><strong><code>.pyo</code>文件类型</strong></p>
<p>当有模块被导入的时候，解释器也会产生<code>.pyo</code>文件，只不过需要告诉解释器开启优化设置。产生<code>.pyo</code>文件就不再产生<code>.pyc</code>文件了（python3.5以前是<code>.pyo</code>，python3.5以后就是产生<code>.opt-1.pyc</code>文件）。源代码变化的时候，<code>.pyo</code>或.<code>opt-1.pyc</code>也会随着变化。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <url>/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="jian-jie-tcp-san-ci-wo-shou-he-si-ci-hui-shou">简解TCP三次握手和四次挥手</h1>
<p>三次握手发生在客户端连接的时候，当调用connect(), 底层会通过TCP协议进行三次握手</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式简解</title>
    <url>/2022/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>经典排序算法</title>
    <url>/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/wallhaven-y8mg97_3840x2160.png" alt="wallhaven-y8mg97_3840x2160" style="zoom:80%;">
<h1 id="gai-nian">概念</h1>
<p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p>
<p>首先需明确以下几个概念：</p>
<ul>
<li><strong>稳定性</strong>：假定在待排序的记录序列中，存在多个具有<u>相同的关键字</u>的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</li>
</ul>
<img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220522171743008.png" alt="image-20220522171743008" style="zoom:80%;">
<ul>
<li><strong>内部排序</strong>：数据元素全部放在内存中的排序。</li>
<li><strong>外部排序</strong>：数据元素太多不能同时放在内存中，根据排序过程的要求不能在<u>内外存之间</u>移动数据的排序。</li>
</ul>
<img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220522171854728.png" alt="image-20220522171854728" style="zoom: 67%;">
<hr>
<h1 id="cha-ru-pai-xu">插入排序</h1>
<p>直接插入排序是一种简单的插入排序法，其是基本思想：</p>
<p>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。</p>
<p>实际中我们玩扑克牌时，就用了插入排序的思想，在排序自己手中的扑克牌时经常会这样排。</p>
<h2 id="zhi-jie-cha-ru-pai-xu">直接插入排序</h2>
<p>当插入第<code>i(i &gt;= 1)</code>个元素时，前面的<code>array[0]</code>, <code>array[1]</code>, <code>…</code>, <code>array[i-1]</code>已经排好序，此时用<code>array[i]</code>的排序码与<code>array[i-1]</code>, <code>array[i-2]</code>, <code>…</code>的排序码顺序进行比较，找到插入位置即将<code>array[i]</code>插入，原来位置上的元素顺序后移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//以end所在位置的前面所有元素已有序</span></span><br><span class="line">        <span class="type">int</span> end = i;</span><br><span class="line">        <span class="comment">//单趟排序</span></span><br><span class="line">        <span class="type">int</span> tmp = arr[end + <span class="number">1</span>]; <span class="comment">//暂存要插入的元素</span></span><br><span class="line">        <span class="keyword">while</span> (end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[end] &gt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[end + <span class="number">1</span>] = arr[end]; <span class="comment">//移开，腾位置</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong>：</p>
<p>☑ 原始集合越接近有序，直接插入排序算法的时间效率越高</p>
<p>☑ 时间复杂度：<strong>O(n^2)</strong></p>
<p>☑ 空间复杂度：<strong>O(1)</strong></p>
<p>☑ 稳定性：稳定</p>
</blockquote>
<h2 id="xi-er-pai-xu-suo-xiao-zeng-liang-pai-xu">希尔排序 (缩小增量排序)</h2>
<p>希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数<code>gap</code>，把待排序文件中所有记录分成多个组，所有距离为**<code>gap</code><strong>的记录分在同一组内，并对每一组内的记录进行排序。然后，取不同的</strong><code>gap</code>**，重复上述分组和排序的工作。</p>
<p><code>gap &gt; 1</code>时在做预排序，当到达<code>gap = 1</code>时相当于做直接插入排序，所有记录再统一组内排好序。</p>
<p>希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>在此我们选择增量 <strong>gap = length / 2</strong>，缩小增量以 <strong>gap = gap / 2</strong> 的方式，用序列 <strong>{n / 2, (n / 2) / 2，…，1}</strong> 来表示。</p>
<p>如图示例：</p>
<img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220522175948956.png" alt="image-20220522175948956" style="zoom:80%;">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> gap = n;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// gap &gt; 1        预排序</span></span><br><span class="line">        <span class="comment">//最后一次gap = 1 直接插入排序</span></span><br><span class="line">        gap = gap / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; i++) &#123;</span><br><span class="line">            <span class="type">int</span> end = i;</span><br><span class="line">            <span class="type">int</span> tmp = arr[end + gap];</span><br><span class="line">            <span class="keyword">while</span> (end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[end] &gt; tmp) &#123;</span><br><span class="line">                    arr[end + gap] = arr[end];</span><br><span class="line">                    end -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[end + gap] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong></p>
<p>☑ 希尔排序是对直接插入排序的优化。<br>
☑ 当<strong>gap&gt;1</strong>时都是预排序，目的是让数组更快接近于有序（跳的快）<br>
当<strong>gap == 1</strong>时（相当于直接插入排序），数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。<br>
希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，因此在好些书中给出的希尔排序<br>
的时间复杂度都不固定：<br>
举个🌰：Knuth在所著的《计算机程序设计技巧》第三卷中，利用大量的实验统计资料得出，当n很大时，关键码平均比较次数和对象平均移动次数大概在范围n^1.25到1.6 * n^1.25范围内，这是利用直接插入排序作为子序列排序方法的情况下得到的。<br>
因为咱们的gap是按照Knuth提出的方式取值的，而Knuth进行了大量的试验统计，<strong>我们暂时就按照：O(n^1.25)到O(1.6 * n^1.25)来算。</strong><br>
☑ 稳定性：不稳定(相同的数据可能被分到不同的gap组)</p>
</blockquote>
<hr>
<h1 id="xuan-ze-pai-xu">选择排序</h1>
<p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。</p>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) min = j;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong>：<br>
☑ 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用<br>
☑ 时间复杂度：<strong>O(n^2)</strong><br>
☑ 空间复杂度：<strong>O(1)</strong><br>
☑ 稳定性：不稳定</p>
</blockquote>
<hr>
<h1 id="mou-pao-pai-xu">冒泡排序</h1>
<p>依次比较两个相邻的元素，如果顺序不符合要求，就交换位置。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。”</p>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" alt="img"></p>
<p>在这里我们加一个<strong>flag</strong>来判断待排序数列是否已经有序（不交换就是已经有序了），这样的一定程度上提高效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//单趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j - <span class="number">1</span>], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>; <span class="comment">//已经有序了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong><br>
☑ 冒泡排序是一种非常容易理解的排序<br>
☑ 时间复杂度：<strong>O(n^2)</strong><br>
☑ 空间复杂度：<strong>O(1)</strong><br>
☑ 稳定性：稳定</p>
</blockquote>
<hr>
<h1 id="kuai-su-pai-xu">快速排序</h1>
<p>快速排序是由Hoare所发展的一种排序算法。快速排序使用分治法（Divide and conquer）策略。<strong>基本思想</strong>为：任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</p>
<p>在平均状况下，排序 n 个元素要 <code>Ο(nlogn)</code> 次比较。在最坏状况下则需要 <code>Ο(n^2)</code> 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 <strong>Ο(nlogn)</strong> 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" alt="img"></p>
<h2 id="ji-ben-shi-xian">基本实现</h2>
<p>采用当前最左侧的元素为划分枢纽，递归法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = arr[l]; <span class="comment">//选取最左侧元素为枢纽</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= tmp) r--;</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= tmp) l++;</span><br><span class="line">        arr[r] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = tmp;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">partition</span>(arr, l, r);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单个函数实现快排：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵划分操作（以 arr[l] 作为基准数）</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">//顺序不能乱</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[l]);</span><br><span class="line">    <span class="comment">// 递归左（右）子数组执行哨兵划分</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, l, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong></p>
<p>☑ 可快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序<br>
☑ 时间复杂度：<strong>O(nlogn)</strong><br>
☑ 空间复杂度：<strong>O(logn)~O(n)</strong> (最坏情况每次key都取到最大或最小，要递归n层)<br>
☑ 稳定性：不稳定(选key, 三数取中，很多因素使它不稳定)</p>
</blockquote>
<h2 id="kuai-pai-de-you-hua">快排的优化</h2>
<h3 id="shu-niu-zhi-xuan-qu">枢纽值选取</h3>
<p><code>partition</code>如果每次选出的<code>key</code>都是最小或最大的会使效率大大降低。例如：1 2 3 4 5 6 这种已经顺序了的，取最左或者最右都会很慢，于是我们想到能否选出一个不是最大也不是最小的数做key。</p>
<ul>
<li>
<p><strong>随机选取法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[<span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l]);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>三数取中法</strong></p>
</li>
</ul>
<p>最左，最右，中间三个位置的数进行比较，选出中等大小的那个做key</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选出中等大小数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMidIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &lt; arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; arr[right]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &lt; arr[right]) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[right] &gt; arr[left]) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[right]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// swap(arr[l], arr[rand() % (r - l + 1) + l]);</span></span><br><span class="line">    <span class="comment">//三数取中</span></span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">getMidIndex</span>(arr, l, r);</span><br><span class="line">    <span class="built_in">swap</span>(arr[m], arr[l]);</span><br><span class="line">    ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="gai-bian-xiao-qu-jian-pai-xu-fang-shi">改变小区间排序方式</h3>
<p>快排的结构是类似于二叉树的，二叉树最后几层的数是最多的，排序难度也很低，是否能够不递归到最小区间，中途就运用另一种排序方法返回有序数组给上一层来优化呢？当然是可以的</p>
<img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220522193251949.png" alt="image-20220522193251949" style="zoom:80%;">
<p>小区间优化：递归到小的子区间时，可以考虑使用插入排序 ，减少递归调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="comment">//以end所在位置的前面所有元素已有序</span></span><br><span class="line">        <span class="type">int</span> end = i;</span><br><span class="line">        <span class="comment">//单趟排序</span></span><br><span class="line">        <span class="type">int</span> tmp = arr[end + <span class="number">1</span>]; <span class="comment">//暂存要插入的元素</span></span><br><span class="line">        <span class="keyword">while</span> (end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[end] &gt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[end + <span class="number">1</span>] = arr[end]; <span class="comment">//移开，腾位置</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加小区间优化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子区间相等只有一个值或者不存在那么就是递归结束的子问题</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt;= <span class="number">3</span>) <span class="built_in">insertSort</span>(arr, l, r); <span class="comment">//13为小区间门槛值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">partition</span>(arr, l, r);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fei-di-gui-shi-xian-kuai-pai">非递归实现快排</h2>
<p>需要用栈实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    stk.<span class="built_in">emplace</span>(begin);</span><br><span class="line">    stk.<span class="built_in">emplace</span>(end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右边处理完了再处理左边</span></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> right = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> left = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> key = <span class="built_in">partition</span>(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; key - <span class="number">1</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(left);</span><br><span class="line">            stk.<span class="built_in">emplace</span>(key - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(key + <span class="number">1</span>);</span><br><span class="line">            stk.<span class="built_in">emplace</span>(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ji-yu-kuai-pai-si-xiang-shi-xian-top-k">基于快排思想实现TopK</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//快速排序划分函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(nums[low], nums[<span class="built_in">rand</span>() % (high - low + <span class="number">1</span>) + low]);<span class="comment">//随机化枢纽</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pivort = nums[low]; <span class="comment">//取第一个元素作为枢轴元素</span></span><br><span class="line">    <span class="type">int</span> low_tmp = low; <span class="comment">//保存low当前下标</span></span><br><span class="line">    <span class="type">int</span> high_tmp = high; <span class="comment">//保存high当前下标</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] &lt;= pivort) high--; <span class="comment">//枢轴元素右边全放小的</span></span><br><span class="line">        nums[low] = nums[high]; <span class="comment">//大的放到左边</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] &gt;= pivort) low++;   <span class="comment">//枢轴元素左边全放大的</span></span><br><span class="line">        nums[high] = nums[low]; <span class="comment">//小的放到右边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当low和high相等时，说明已经排好了，把枢轴元素放好</span></span><br><span class="line">    nums[low] = pivort;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//判断枢轴元素是否是第k个最大的元素</span></span><br><span class="line">    <span class="keyword">if</span>(low == k<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(low &gt; k<span class="number">-1</span>)&#123; <span class="comment">//如果当前枢轴元素索引比k-1大，说明要在左边找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Partition</span>(nums, low_tmp, low<span class="number">-1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//如果当前枢轴元素索引比k-1小，说明要在右边找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Partition</span>(nums, low + <span class="number">1</span>, high_tmp, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Partition</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>, k); <span class="comment">//递归划分查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">4</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">findKthLargest</span>(arr, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="dui-pai-xu">堆排序</h1>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法，是选择排序的一种。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ol>
<li><strong>大顶堆</strong>：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li><strong>小顶堆</strong>：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ol>
<p>堆排序的平均时间复杂度为 <code>Ο(nlogn)</code>。</p>
<p><strong>步骤（以大顶堆为例）：</strong></p>
<ul>
<li>
<p><strong>建堆过程</strong>：将数组看成一个假想的完全二叉树，从第一个非叶子节点开始往上操作，每次操作的内容是保证当前节点是自己和左右节点中的最大值，不是则进行交换达成这个目标，继续往下进行这个下沉操作直到叶子节点为止，这样第一次建树后肯定是根节点最大</p>
</li>
<li>
<p><strong>排序过程</strong>：将根节点换到数组的最后面去，然后需要排序的数组长度-1。之后就是从根节点开始进行下沉操作让根节点最大了，建树的时间复杂度为看起来<strong>N/2 * logN</strong>，实际计算出来时<strong>O(N)</strong></p>
</li>
</ul>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/heapSort.gif" alt="img"></p>
<p>如果按照从最后一个非叶子节点开始往上操作的话复杂度就是N，每次调整堆的复杂度为<strong>logn</strong></p>
<h2 id="shi-xian">实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxIdx = m;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span> * m + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">2</span>  * m + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; len &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; len &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line">        <span class="keyword">if</span>(maxIdx != m)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[m], nums[maxIdx]);</span><br><span class="line">            <span class="built_in">heapify</span>(nums, maxIdx, len);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>] , arr[len - <span class="number">1</span>]);</span><br><span class="line">        len--;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">heapSort</span>(arr);</span><br><span class="line">    for_each(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123;cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong><br>
☑ 堆排序使用堆来选数，效率就高了很多。<br>
☑ 时间复杂度：<strong>O(nlogn)</strong><br>
☑ 空间复杂度：<strong>O(1)</strong><br>
☑ 稳定性：不稳定</p>
</blockquote>
<h2 id="jian-dui-shi-jian-fu-za-du-fen-xi">建堆时间复杂度分析</h2>
<p>堆排序主要分<strong>建堆</strong>和<strong>调整</strong>两个操作，我们先分别来分析两个阶段的时间复杂度</p>
<ul>
<li>筛选法建堆</li>
</ul>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220522202250476.png" alt="image-20220522202250476"></p>
<p>筛选法<strong>最好时间复杂度</strong>：当按顺序生成的完全二叉树就满足堆的要求的时候，那么步骤(2) 中每个节点只需要进行两次比较(一次为左右孩子比较，第二次是与最大的孩子节点进行比较),所以最好时间复杂度为 <strong>O(n)</strong></p>
<p>筛选法<strong>最坏时间复杂度</strong>：当每次检查都需要交换并且一直检查到叶子节点时：第k层节点最多需要向下移动h-k次，h为堆高，由二叉树的性质可知，第k层最多有2^(k-1)个节点，</p>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220522202554428.png" alt="image-20220522202554428"></p>
<p>所以筛选法建堆的最坏时间复杂度至少为O(n)量级。</p>
<hr>
<h1 id="gui-bing-pai-xu">归并排序</h1>
<p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide andConquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/23534.gif" alt="23534" style="zoom: 67%;">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span>  l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l  &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + ((r - l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 将两段排序合并</span></span><br><span class="line">    <span class="type">int</span>  k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        tmp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = arr[j++];</span><br><span class="line">    <span class="comment">// 复制回来原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i) arr[l + i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong><br>
☑ 归并的缺点在于需要**O(n)**的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。<br>
☑ 时间复杂度：<strong>O(nlogn)</strong><br>
☑ 空间复杂度：<strong>O(n)</strong><br>
☑ 稳定性：稳定</p>
</blockquote>
<h2 id="fei-di-gui-shi-xian-gui-bing-pai-xu">非递归实现归并排序</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span>  l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n) &#123;</span><br><span class="line">        <span class="comment">//间距为gap为一组，两两归并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//只有end1越界，直接修正</span></span><br><span class="line">            <span class="keyword">if</span> (end1 &gt;= n) end1 = n - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// begin2不存在，第二个区间不存在,修正成一个不存在的区间</span></span><br><span class="line">            <span class="keyword">if</span> (begin2 &gt;= n) &#123;</span><br><span class="line">                begin2 = n;</span><br><span class="line">                end2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// begin2没事end2越界，修正end2</span></span><br><span class="line">            <span class="keyword">if</span> (end2 &gt;= n) end2 = n - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将两段排序合并</span></span><br><span class="line">            <span class="type">int</span> index = i;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">                tmp[index++] = arr[begin1] &lt;= arr[begin2] ? arr[begin1++] : arr[begin2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1) tmp[index++] = arr[begin1++];</span><br><span class="line">            <span class="keyword">while</span> (begin2 &lt;= end2) tmp[index++] = arr[begin2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制回来原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i) arr[l + i] = tmp[i];</span><br><span class="line"></span><br><span class="line">        gap *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>以上排序算法都是基于元素比较的排序算法。接下来介绍的计数排序、基数排序、桶排序都是<strong>非比较排序算法</strong>。</p>
</blockquote>
<h1 id="ji-shu-pai-xu">计数排序</h1>
<p>思想：计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用。</p>
<p>操作步骤：</p>
<ul>
<li>统计相同元素出现次数</li>
<li>根据统计的结果将序列回收到原来的序列中</li>
</ul>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/countingSort.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适用于范围集中的数，排负数也行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> minElem = *<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> maxElem = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> range = maxElem - minElem + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(range)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cnt[arr[i] - minElem]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt[i]--) &#123;</span><br><span class="line">            arr[index++] = i + minElem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong><br>
☑ 计数排序在数据范围集中时，效率很高，但是适用范围及场景有限，浮点数就没法排，<br>
☑ 时间复杂度：O(max(n, range)<br>
☑ 空间复杂度：O(range)<br>
☑ 稳定性：稳定</p>
</blockquote>
<hr>
<h1 id="tong-pai-xu-xiang-pai-xu">桶排序（箱排序）</h1>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 <strong>N</strong> 个数据均匀的分配到 <strong>K</strong> 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p><strong>操作步骤</strong></p>
<ul>
<li>设置一个定量的数组当作空桶；</li>
<li>每个桶存放该区间的数据，由于每个桶内的数据元素个数不确定，可以使用链表表示，同时使用插入排序，让每个桶的链表有序。</li>
<li>这样按照次序将所有桶的元素连起来就得到完整的有序列表。</li>
</ul>
<img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/23523.png" alt="23523" style="zoom: 67%;">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(list&lt;<span class="type">int</span>&gt;&amp; bucket, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = bucket.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != bucket.<span class="built_in">end</span>() &amp;&amp; val &gt;= *iter)</span><br><span class="line">        ++iter;</span><br><span class="line">    <span class="comment">// insert会在iter之前插入数据，这样可以稳定排序</span></span><br><span class="line">    bucket.<span class="built_in">insert</span>(iter, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minElem = *<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> maxElem = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">10</span>; <span class="comment">// k为数字之间的间隔</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向上取整，例如[0,9]有10个数，(9 - 0)/k + 1 = 1;</span></span><br><span class="line">    <span class="type">int</span> bucketsNum = (maxElem - minElem) / k + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketsNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> value = arr[i];</span><br><span class="line">        <span class="comment">//(value-min)/k就是在哪个桶里面</span></span><br><span class="line">        <span class="built_in">insert</span>(buckets[(value - minElem) / k], value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketsNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!buckets[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : buckets[i])</span><br><span class="line">                arr[index++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理论上来讲，桶的数量越多，时间复杂度就越低，当然空间复杂度就越高。而且和计数排序很相似，如果桶的数量是 <strong>max - min + 1</strong>，这个时候，桶排序和计数排序几乎就是一样的。</p>
<blockquote>
<p><strong>总结：</strong><br>
时间复杂度：<strong>O(range+n)</strong><br>
空间复杂度：<strong>O(range+n)</strong><br>
稳定性：稳定</p>
</blockquote>
<h2 id="xing-neng-fen-xi">性能分析</h2>
<p>你可能会有一个疑问：每个桶内再用其他的排序算法进行排序（比如快排）,这样子时间复杂度不还是O(nlogn)吗？</p>
<p>如果要排序的数据有n个，我们把它们分在m个桶中，这样每个桶里的数据就是k = n / m。每个桶内排序的时间复杂度就为O(k*logk)。m个桶就是m * O(k * logk)=m * O((n / m)*log(n / m))=O(nlog(n / m))。当桶的个数m接近数据个数n时，log（n/m）就是一个较小的常数，所以时间复杂度接近O(n)。</p>
<h2 id="ying-yong-chang-jing">应用场景：</h2>
<p>看了上面的分析，既然桶排序时间复杂度为线性，是不是就能替代例如快排、归并这种时间复杂度为O(nlogn)的排序算法呢？</p>
<p>答案是否定的，桶排序的应用场景十分严苛，首先，<strong>数据应该分布比较均匀</strong>。讲一种较坏的情况，如果数据全部都被分到一个桶里，那么桶排序的时间复杂度是不是就退化到O(nlogn)了呢？其次，<strong>要排序的数据应该很容易分成m个桶，每个桶也应该有大小顺序</strong>。</p>
<hr>
<h1 id="ji-shu-pai-xu-1">基数排序</h1>
<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p><strong>步骤</strong>：</p>
<p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/radixSort.gif" alt="img"></p>
<h2 id="shi-xian-1">实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求最大位数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxBit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxElem = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxElem &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        maxElem /= <span class="number">10</span>;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">maxBit</span>(arr);</span><br><span class="line">    <span class="type">int</span> curRadix = <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> bucket[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计每个桶的数据个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bucket[arr[i] / curRadix % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向tmp数组存入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp[bucket[arr[i] / curRadix % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            bucket[arr[i] / curRadix % <span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将tmp序列拷贝到原数组中</span></span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), arr.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">        curRadix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong><br>
☑ 时间复杂度：<strong>O(range * n)</strong><br>
☑ 空间复杂度：<strong>O(range+n)</strong><br>
☑ 稳定性：稳定。</p>
</blockquote>
<h2 id="ji-shu-pai-xu-vs-ji-shu-pai-xu-vs-tong-pai-xu">基数排序 vs 计数排序 vs 桶排序</h2>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<hr>
<h1 id="pai-xu-suan-fa-zong-jie">排序算法总结</h1>
<p><img src="/2022/05/23/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220522222700971.png" alt="image-20220522222700971"></p>
<h1 id="qi-ta">其他</h1>
<h2 id="swap-cao-zuo-li-yong-yi-huo-yun-suan">swap操作–利用异或运算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：a, b所处的地址不同才可以，否则会变成零！双重for循环操作数组时，i与j不能相等否则犯错！</p>
<h2 id="shi-ji-ying-yong-kuai-pai-yu-dui-pai-xuan-ze">实际应用快排与堆排选择</h2>
<p>相同的数据规模，快速排序比堆排序的效率高很多，并且随着数据规模的扩大，二者的差距不断扩大，快速排序的优势越来越明显。快速排序的时间复杂度近似线性增长，堆排序则要大很多。究其原因，应该有以下几个方面：</p>
<ul>
<li>
<p>在堆排序（小根堆）的时候，每次总是将最小的元素移除，然后将最后的元素放到堆顶，再让其自我调整。这样一来，有很多比较将是被浪费的，因为被拿到堆顶的那个元素几乎肯定是很大的，而靠近堆顶的元素又几乎肯定是很小的，最后一个元素能留在堆顶的可能性微乎其微，最后一个元素很有可能最终再被移动到底部。<strong>在堆排序里面有大量这种近乎无效的比较</strong>。随着数据规模的增长，比较的开销最差情况应该在（线性*对数）级别，如果数据量是原来的10倍，那么用于比较的时间开销可能是原来的<code>10log10</code>倍。</p>
</li>
<li>
<p>堆排序的过程中，<strong>需要有效的随机存取</strong>。比较父节点和字节点的值大小的时候，<strong>虽然计算下标会很快完成，但是在大规模的数据中对数组指针寻址也需要一定的时间</strong>。<strong>而快速排序只需要将数组指针移动到相邻的区域即可。在堆排序中，会大量的随机存取数据</strong>；<strong>而在快速排序中，只会大量的顺序存取数据</strong>。随着数据规模的扩大，这方面的差距会明显增大。在这方面的时间开销来说，快速排序只会线性增长，而堆排序增加幅度很大，会远远大于线性。</p>
</li>
<li>
<p><strong>在快速排序中，每次数据移动都意味着该数据距离它正确的位置越来越近，而在堆排序中，类似将堆尾部的数据移到堆顶这样的操作只会使相应的数据远离它正确的位置</strong>，后续必然有一些操作再将其移动，即“做了好多无用功”。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>STL剖析</title>
    <url>/2022/05/18/STL%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<img src="/2022/05/18/STL%E5%89%96%E6%9E%90/34653464.png" alt="34653464" style="zoom:67%;">
<h1 id="stl-shi-xian-yuan-li-ji-shi-xian">STL实现原理及实现</h1>
<p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是：容器、算法、迭代器、仿函数、适配器（配器）、空间配置器。</p>
<p>STL六大组件的交互关系：</p>
<ol>
<li>容器通过空间配置器取得数据存储空间</li>
<li>算法通过迭代器存储容器中的内容</li>
<li>仿函数可以协助算法完成不同的策略的变化</li>
<li>适配器可以修饰仿函数。</li>
</ol>
<p><strong>容器</strong><br>
各种数据结构，如vector、Iist、deque、set、map等，用来存放数据，从实现角度来看，STL容器是一种class template。</p>
<p><strong>算法</strong><br>
各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p>
<p><strong>迭代器</strong><br>
扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将<code>operator*</code>, <code>operator-&gt;</code>, <code>operator++</code>, <code>operator--</code> 等指针相关操作予以重载的class template。</p>
<p>所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。<br>
原生指针(native pointer)也是一种迭代器。</p>
<p><strong>仿函数</strong><br>
行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了<code>operator()</code>的class或者class template。</p>
<p><strong>适配器</strong><br>
一种用来修饰容器或者仿函数或迭代器接口的东西。</p>
<p>STL提供的queue和stack,虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque, 所有操作都由底层的deque供应。</p>
<p><strong>空间配置器</strong><br>
负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。<br>
一般的分配器的<code>std::alloctor</code>都含有两个函数<code>allocate</code>与<code>deallocte</code>,这两个函数分别调用<code>operator new()</code>与<code>delete()</code>,这两个函数的底层又分别是<code>malloc()</code> 和 <code>free()</code>; 但是每次malloc会带来格外开销（因为每次malloc一个元素都要带有附加信息）</p>
<hr>
<h1 id="kong-jian-pei-zhi-qi-code-allocate-code">空间配置器（<code>allocate()</code>）</h1>
<blockquote>
<p>SGI STL 为了避免小型区块的内存碎片（fragment）问题, SGI设计了两级配置器</p>
</blockquote>
<p>当配置区块大于128字节时，调用第一级配置器。小于128字节时调用第二级配置器。</p>
<p><strong>为什么需要二级空间配置器？</strong></p>
<p>我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片，浪费了内存空间；</p>
<p>每次都要进行调用malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率；</p>
<p>随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。</p>
<p>于是就设置了二级空间配置器，当开辟内存&lt;=128bytes时，即视为开辟小块内存，则调用二级空间配置器。</p>
<p><strong>为什么这样区分成两级？</strong></p>
<p>​    因为STL容器，一般申请的都会是小块的内存。 二级空间配置器，主要是管理容器申请空间和释放的空间。如果用户申请的空间直接大于的<strong>128</strong>字节直接找的是一级空间配置器申请空间。</p>
<blockquote>
<p>一级空间配置器</p>
</blockquote>
<p>第一级配置器**（alloc）**的<code>allocate()</code>和<code>deallocate()</code>函数只是简单调用<code>malloc()</code>、<code>free()</code>和<code>relloc()</code>函数；</p>
<p>一级空间配置器原理很简单，直接是对malloc和free进行了封装，并且增加了C++中的set_new_handle思想，即申请空间失败抛异常机制。</p>
<blockquote>
<p>二级空间配置器</p>
</blockquote>
<p>第二级配置器为了降低额外开销（overhead），采用<strong>内存池</strong>(memory pool)管理内存分配；具体使用的内存块从free-list(自由链表)中提取出。</p>
<p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</p>
<img src="/2022/05/18/STL%E5%89%96%E6%9E%90/3453.png" alt="3453" style="zoom: 67%;">
<p><strong>具体流程为：</strong></p>
<ul>
<li>
<p>空间配置函数<code>allocate()</code>，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</p>
</li>
<li>
<p>空间释放函数<code>deallocate()</code>，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</p>
</li>
</ul>
<p>1.当需要申请的内存大小N 大于128bytes时，直接使用第一级配置器，使用malloc分配</p>
<p>2.小于等于128bytes时，使用内存池管理。内存池管理步骤为：</p>
<p>​	a. 首先查看是否有可用的free-list，如果有就直接使用。没有的话，将所需区块大小上调至8的倍数，调用  refill()为free list重新分配空间。</p>
<p>​	b. 新的空间将取自内存池（经由chunk_alloc()完成），如果内存池不够用，从堆空间（malloc配置空间）  拿来补充内存池。如果堆空间也不够了，就调用第一级配置器来补充内存池。因为第一级配置器有out-of- memory处理机制，看看它能不能释放其它内存然后拿来此处使用（如果可以就成功，否则bad_alloc异常）。</p>
<p><strong>这里要注意一点，最初内存池和free list都为空。</strong></p>
<hr>
<h1 id="die-dai-qi">迭代器</h1>
<h2 id="gai-nian">概念</h2>
<p>STL的中心思想：将数据容器(containers)和算法(algorithms)分开，彼此独立设计，最后再以胶着剂将它们撮合在一起。那么之间的<strong>胶着剂就是迭代器(iterator)</strong></p>
<p>迭代器 iterator是一种<strong>智能指针</strong>(smart pointer)</p>
<p>迭代器是一种行为类似指针的对象(智能指针对象)，其行为包括内容提领(deference)和成员访问(member access)，所以迭代器要对<code>operator&amp;()</code>和<code>operator*()</code>进行重载，同时要兼顾自身的有效性(析构)的问题。</p>
<blockquote>
<p>在实际的算法中，在运用迭代器时，会用到迭代器所指对象中的相应类型(associate type)。</p>
</blockquote>
<p>那么算法实现中该如何满足 <strong>声明一个以“迭代器所指对象(中)的类型”为类型的成员/参数，或返回值是“迭代器所指对象(中)的类型”的类型</strong> 的需求呢？</p>
<p>可分为以下三种情况：</p>
<p>​	① 迭代器所指对象是c++内置类型；<br>
​	② 迭代器所指对象是自定义类型(class type)情形;<br>
​	③ 迭代器所指对象是原生指针(naive pointer)情形;</p>
<p>对应的运用以下三种方法解决：</p>
<p>​	① function template的参数推导(augument deducation)机制 ；<br>
​	② 声明内嵌类型 ；<br>
​	③ 利用泛化中偏特化(partial secification)(下面有解释) ；<br>
​	envolve to ：萃取机 iterator_traits 机制</p>
<p><strong>这三种方法是逐步整合为最终的实现的方案就是 *iterator_traits萃取机* 机制，它包含了函数模板的参数推导，声明内嵌类型和偏特化所有内容，也同时解决了以上的三个场景的实现需求。</strong></p>
<p>结合以上三种情况和三种解决方法，最终设计出了<strong>迭代器萃取机这一中间层，其作用是萃取出迭代器的相关特性（也即是相应类型的取用），以屏蔽迭代器实现对算法实现的影响</strong></p>
<img src="/2022/05/18/STL%E5%89%96%E6%9E%90/20210305145003405.png" alt="img" style="zoom:80%;">
<h2 id="traits-ji-fa">traits技法</h2>
<p>traits技法利用“内嵌型别“的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。</p>
<ol>
<li>
<p>iterator_traits</p>
<p>被称为特性萃取机，能够方面的让外界获取以下5中型别：</p>
<ul>
<li>value_type：迭代器所指对象的型别</li>
<li>difference_type：两个迭代器之间的距离</li>
<li>pointer：迭代器所指向的型别</li>
<li>reference：迭代器所引用的型别</li>
<li>iterator_category：三两句说不清楚，建议看书</li>
</ul>
</li>
<li>
<p>type_traits</p>
<p>关注的是型别的特性，例如这个型别是否具备non-trivial defalt ctor（默认构造函数）、non-trivial copy ctor（拷贝构造函数）、non-trivial assignment operator（赋值运算符） 和non-trivial dtor（析构函数），如果答案是否定的，可以采取直接操作内存的方式提高效率，一般来说，type_traits支持以下5中类型的判断：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor</span><br><span class="line">__type_traits&lt;T&gt;::is_POD_typ</span><br></pre></td></tr></table></figure>
<p>由于编译器只针对class object形式的参数进行参数推到，因此上式的返回结果不应该是个bool值，实际上使用的是一种空的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span>&#123;&#125;;<span class="keyword">struct</span> <span class="title class_">__false_type</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这两个结构体没有任何成员，不会带来其他的负担，又能满足需求，可谓一举两得</p>
<p>当然，如果我们自行定义了一个Shape类型，也可以针对这个Shape设计type_traits的特化版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;Shape&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="rong-qi">容器</h1>
<p>如何选择容器适配器：</p>
<p><img src="/2022/05/18/STL%E5%89%96%E6%9E%90/645624.png" alt="645624"></p>
<h2 id="xu-lie-shi-rong-qi">序列式容器</h2>
<h3 id="vector-xiang-liang">vector - 向量</h3>
<p>vector采用的数据结构非常简单，线性连续空间，它以两个迭代器<code>_Myfirst</code>和<code>_Mylast</code>分别指向配置得来的连续空间中已被使用的范围，并以迭代器<code>Myend</code>指向整块连续内存空间的尾端。</p>
<p>为了降低空间配置时的成本，vector实际配置的大小可能比用户端需求大一些，以备将来可能的扩充，这便是<strong>容量</strong>的概念</p>
<blockquote>
<p>所谓动态增加大小，并不是在原空间之后续接新空间（因为无法保证原空间之后尚有可配置的空间），而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。</p>
<p>因此，<strong>对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了</strong>。</p>
</blockquote>
<h4 id="shi-xian-xi-jie">实现细节</h4>
<p>vector的底层其实仍然是定长数组，它能够实现动态扩容的原因是增加了避免数量谥出的操作。<br>
首先需要指明的是vector中元素的数量（长度）n与它已分配内存最多能包含元素的数量（容量）N是不一致的，vector会分开存储这两个量。当向vector中添加元素时，如发现n&gt;N，那么容器会分配一个尺寸为<strong>2</strong>N的数组，然后将旧数据从原本的位置拷贝到新的数组中，再将原来的内存释放。尽管这个操作的渐进复杂度是O(n), 但是可以证明其均摊复杂度为O(1)。而在末尾删除元素和访问元素则都仍然是O(1)的开销。因此，只要对vector的尺寸估<br>
计得当并善用<code>resize()</code>和<code>reserve()</code>,就能使得vector的效率与定长数组不会有太大差距。</p>
<h4 id="chang-du-he-rong-liang">长度和容量</h4>
<blockquote>
<p>vector有两个参数，一个是size，表示当前vector容器内存储的元素个数，一个是capacity，表示当前vector在内存中申请的这片区域所能容纳的元素个数</p>
</blockquote>
<p>vector 的reserve增加了vector的capacity，但是它的size没有改变！而resize改变了vector的capacity同时也增加了它的size！</p>
<p>原因如下：</p>
<ul>
<li><code>reserve</code>是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用 <strong>push_back()</strong> / <strong>insert()</strong> 函数。</li>
<li><code>resize</code>是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用**operator[]**操作符，或者用迭代器来引用元素对象。此时再调用 <strong>push_back()</strong>     函数，是加在这个新的空间后面的。</li>
</ul>
<p>两个函数的参数形式也有区别的，reserve函数之后一个参数，即需要预留的容器的空间；resize函数可以有两个参数，第一个参数是容器新的大小， 第二个参数是要加入容器中的新元素，如果这个参数被省略，那么就调用元素对象的默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vect;</span><br><span class="line">  </span><br><span class="line">    vect.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vect.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vect.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    vect.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    vect.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    cout&lt;&lt;vect.<span class="built_in">size</span>()&lt;&lt;endl;  <span class="comment">//size为4，但是capacity为10</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reserve()</code> 使得vector 预留一定的内存空间，避免不必要的内存拷贝。</li>
<li><code>capacity()</code> 返回容器的容量，即不发生拷贝的情况下容器的长度上限。</li>
<li><code>shrink_to_fit()</code> 使得vector的容量与长度一致，多退但不会少。</li>
</ul>
<h4 id="vector-de-assign-han-shu-yong-fa">vector的assign()函数用法</h4>
<p>函数原型是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(const_iterator first,const_iterator last)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(size_type n,<span class="type">const</span> T&amp; x = T())</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个相当于个拷贝函数，把first到last的值赋值给调用者；（注意区间的闭合）</p>
<p>第二个把n个x赋值给调用者；</p>
<p>eg:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ls = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">ls1.<span class="built_in">assign</span>(ls.<span class="built_in">begin</span>(),ls.<span class="built_in">begin</span>()+<span class="number">9</span>);</span><br><span class="line"><span class="comment">//打印为：0 1 2 3 4 5 6 7 8</span></span><br><span class="line">ls2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">//打印为：7777777777</span></span><br></pre></td></tr></table></figure>
<h4 id="pai-xu">排序</h4>
<ul>
<li>默认升序排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>降序排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); </span><br></pre></td></tr></table></figure>
<ul>
<li>自定义排序规则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用lambda函数</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; b;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//或者  </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a * a &lt; b * b;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(),cmp);</span><br></pre></td></tr></table></figure>
<h4 id="zui-da-yuan-su-max-element">最大元素（max_element）</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取最大元素所在迭代器</span></span><br><span class="line"><span class="keyword">auto</span> maxVal =  <span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最大元素所在位置</span></span><br><span class="line"><span class="type">int</span> maxIndex =  <span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()) - arr,<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>
<h4 id="tips">Tips</h4>
<ul>
<li>
<p>vector和list由于查找某个元素是O(n)复杂度的，所以不提供<code>find()</code>。而set和map是由关键字排序，底层是红黑树，进行查找的话时间复杂度是O(logn)所以提供<code>find()</code></p>
</li>
<li>
<p>vector可以使用泛型find</p>
<p><code>find(vec.begin(), vec.end(), val) == vec.end();</code></p>
<p>如果vec中存储的是pair 类型，val最好先用<code>make_pair</code>定义好再去找</p>
</li>
<li>
<p>vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效。</p>
<p>list 的插入操作（insert）和接合操作（splice）都不会造成原有list迭代器失效。甚至list的元素删除操作（erase）也只有“指向被删除元素”的那个迭代器失效，其他迭代器不受任何影响</p>
</li>
</ul>
<hr>
<h3 id="string-zi-fu-chuan">string - 字符串</h3>
<p>头文件<code>&lt;string&gt;</code></p>
<blockquote>
<p>string 和 C风格字符串对比</p>
</blockquote>
<ul>
<li>
<p><code>char*</code>是一个指针，<code>string</code>是一个类</p>
<p><code>string</code>封装了<code>char*</code>，管理这个字符串，是一个<code>char*</code>型的容器。</p>
</li>
<li>
<p><code>string</code> 封装了很多实用的成员方法</p>
<p>查找<code>find</code>，拷贝<code>copy</code>，删除<code>erase</code>，替换<code>replace</code>，插入<code>insert</code>等</p>
</li>
<li>
<p>不用考虑内存释放和越界</p>
<p><code>string</code>管理<code>char*</code>所分配的内存，每一次<code>string</code>的复制/赋值，取值都由<code>string</code>类负责维护，不用担心复制越界和取值越界等。</p>
<p><code>string</code> 本质上是一个动态的char数组。</p>
</li>
</ul>
<h4 id="strong-zhuan-char-shu-zu-strong"><strong>转char数组</strong></h4>
<p>在C语言里，也有很多字符串的函数，但是它们的参数都是char指针类型的，为了方便使用，string有两个成员函数能够将自己转换为char指针-- <code>data()</code>/<code>c_str()</code>(它们几乎是一样的，但最好使用<code>c_str()</code>,因为<code>c_str()</code>保证末尾有空字符，而<code>data()</code>则不保证），如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="comment">//编译错误</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">data</span>()); <span class="comment">//编译通过，但是undefined behavior</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>()); <span class="comment">//一定能够正确输出</span></span><br></pre></td></tr></table></figure>
<h4 id="strong-huo-qu-chang-du-strong"><strong>获取长度</strong></h4>
<p>许多函数可以返回string的长度：<code>s.size()</code>  <code>s.length()</code>  <code>strlen(s.c_str())</code></p>
<blockquote>
<p>这些函数的复杂度</p>
<p>strlen(s.c_str()) 的复杂度是与字符串长度线性相关的</p>
<p>size() 和 length() 复杂度在C++11中被指定为常数复杂度</p>
</blockquote>
<h4 id="strong-xun-zhao-mou-zi-fu-chuan-di-yi-ci-chu-xian-de-wei-zhi-strong"><strong>寻找某字符（串）第一次出现的位置</strong></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">//查找字符a第一次出现的位置</span></span><br><span class="line">s.<span class="built_in">find</span>(t) <span class="comment">//查找字符串t第一次出现的位置</span></span><br><span class="line">s.<span class="built_in">find</span>(t, pos) <span class="comment">//查找s中自pos位置起字符串t第一次出现的位置</span></span><br></pre></td></tr></table></figure>
<p>未找到返回-1</p>
<h4 id="strong-jie-qu-zi-chuan-strong"><strong>截取子串</strong></h4>
<p><code>substr(pos, len)</code>, 这个函数的参数是从pos位置开始截取最多len个字符（如果从pos开始的后缀长度不足len则截取这个后缀）</p>
<h4 id="shan-chu-yuan-su">删除元素</h4>
<p><code>erase(pos)</code>和<code>erase(pos, len)</code>删除字符串中下标为pos开始的指定长度的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;123456789&quot;</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出为 123</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;123456789&quot;</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出为 12356789</span></span><br></pre></td></tr></table></figure>
<h4 id="strong-string-he-c-style-zi-fu-chuan-de-zhuan-huan-strong"><strong>string 和C-style 字符串的转换</strong></h4>
<ul>
<li>string 转 const char*</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>const char* 转 string</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(cstr)</span></span>; <span class="comment">//本质上其实是一个有参构造</span></span><br></pre></td></tr></table></figure>
<h4 id="string-replace-xiang-jie">string replace详解</h4>
<blockquote>
<p><strong>replace算法：</strong></p>
<p>​        replace函数包含于头文件#include<string>中。</string></p>
<p>​        泛型算法replace把队列中与给定值相等的所有值替换为另一个值，整个队列都被扫描，即此算法的各个版本都在线性时间内执行——其复杂度为O(n)。</p>
<p>​        即replace的执行要遍历由区间[frist，last)限定的整个队列，以把old_value替换成new_value。</p>
</blockquote>
<p>下面说下replace()的九种用法：</p>
<ol>
<li>
<p><strong>用法一：用str替换指定字符串从起始位置pos开始长度为len的字符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> string&amp; str)</span></span>; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法二： 用str替换 迭代器起始位置 和 结束位置 的字符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">const</span> string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法三： 用substr的指定子串（给定起始位置和长度）替换从指定位置上的字符串</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法四： 用str替换从指定位置0开始长度为5的字符串</strong> （string转char*时编译器可能会报出警告，不建议这样做）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法五：用str替换从指定迭代器位置的字符串</strong> （string转char*时编译器可能会报出警告，不建议这样做）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法六：用s的前n个字符替换从开始位置pos长度为len的字符串</strong> （string转char*时编译器可能会报出警告，不建议这样做）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法七：用s的前n个字符替换指定迭代器位置(从i1到i2)的字符串</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法八：用重复n次的c字符替换从指定位置pos长度为len的内容</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法九： 用重复n次的c字符替换从指定迭代器位置（从i1开始到结束）的内容</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="list-lian-biao">list - 链表</h3>
<p>链表是一种物理存储单元上非连、续非顺序的储存结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p>list 容器是一个双向链表，且是<strong>循环的双向链表</strong></p>
<p><img src="/2022/05/18/STL%E5%89%96%E6%9E%90/235346457.png" alt="235346457"></p>
<p>相较于vector的连续线性空间，list就显得复杂许多。</p>
<ul>
<li>它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间</li>
<li>因此，list对于空间的运用有绝对的精准，一点也不浪费</li>
<li>而且，list对于任何位置插入或删除元素都是常数项时间</li>
</ul>
<blockquote>
<p>list 有一个重要的性质，插入和删除操作都不会造成原有list迭代器的失效</p>
<ul>
<li>这在vector是不成立的，因为vector的插入操作可能会造成内存的重新配置，导致原有的迭代器全部失效</li>
<li>而list元素的删除只会使得被删除元素的迭代器失效</li>
</ul>
</blockquote>
<h4 id="bian-li">遍历</h4>
<ul>
<li>顺序遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(list&lt;T&gt;::iterator it = lst.<span class="built_in">begin</span>(); it != lst.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>逆序遍历</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(list&lt;T&gt;::reverse_iterator it = lst.<span class="built_in">rbegin</span>(); it != lst.<span class="built_in">rend</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gou-zao-han-shu">构造函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;T&gt; lstT; <span class="comment">// 默认构造形式，list采用模版类实现</span></span><br><span class="line"><span class="built_in">list</span>(beg, end); <span class="comment">// 构造函数将[beg, end)区间内的元素拷贝给本身</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">int</span> n, T elem); <span class="comment">// 构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list&amp; lst); <span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h4 id="yuan-su-cha-ru-he-shan-chu-cao-zuo">元素插入和删除操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T elem)</span></span>; <span class="comment">// 在容器尾部加入一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">// 删除容器中最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T elem)</span></span>; <span class="comment">// 在容器开头插入一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>; <span class="comment">// 从容器开头移除第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(iterator pos, elem); <span class="comment">// 在pos位置插入elem元素的拷贝，返回新数据的位置</span></span><br><span class="line"><span class="built_in">insert</span>(iterator pos, n, elem); <span class="comment">// 在pos位置插入n个elem元素的拷贝，无返回值</span></span><br><span class="line"><span class="built_in">insert</span>(iterator pos, beg, end); <span class="comment">// 在pos位置插入[beg, end)区间内的数据，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 移除容器的所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(beg, end); <span class="comment">// 删除[beg, end)区间内的所有数据，返回下一个数据的位置</span></span><br><span class="line"><span class="built_in">erase</span>(pos); <span class="comment">// 删除pos位置的数据，返回下一个数据的位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">remove</span>(elem); <span class="comment">// 删除容器中所有与elem匹配的元素</span></span><br></pre></td></tr></table></figure>
<h4 id="fu-zhi-cao-zuo">赋值操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end); <span class="comment">// 将[beg, end)区间中的数据拷贝赋值给本身</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem); <span class="comment">// 将n个elem拷贝赋值给本身</span></span><br><span class="line"></span><br><span class="line">list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list&amp; lst); <span class="comment">// 重载等号操作符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(lst); <span class="comment">// 将lst与本身的元素互换</span></span><br></pre></td></tr></table></figure>
<h4 id="fan-zhuan-ji-pai-xu">反转及排序</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>; <span class="comment">// 反转链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>; <span class="comment">// 默认list排序，规则为从小到大</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">bool</span> (*cmp)(T item1, T item2))</span></span>; <span class="comment">// 指定排序规则的list排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为所有系统提供的某些算法（比如排序），其迭代器必须支持随机访问</span></span><br><span class="line"><span class="comment">// 不支持随机访问的迭代器的容器，容器本身会对应提供相应的算法的接口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能用sort(lst.begin(), lst.end())</span></span><br><span class="line"><span class="comment">//应该使用下列形式</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; p1, T&amp; p2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.val &lt; p2.val;</span><br><span class="line">&#125;</span><br><span class="line">ls.<span class="built_in">sort</span>(myCompare);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="array-ding-chang-shu-zu">array - 定长数组</h3>
<p><code>std::array</code>是STL提供的内存连续的、固定长度的数组数据结构，其本质是对原生数组的直接封装。</p>
<h4 id="gai-nian-1">概念</h4>
<p>array实际上是STL对数组的封装。它相比vector牺牲了动态扩容的特性，但是换来了与原生数组几乎一致的性能（在开满优化的前提下）。因此如果能使用C++11特性的情况下，能够使用原生数组的地方几乎都可以直接把定长数组都换成array， 而动态分配的数组可以替换为vector。和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。</p>
<h4 id="chu-shi-hua-fang-shi">初始化方式</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values;</span><br><span class="line"> </span><br><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values &#123;&#125;; <span class="comment">//所有的元素初始化为 0 或者和默认元素</span></span><br><span class="line"> </span><br><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="cheng-yuan-han-shu">成员函数</h4>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的随机访问迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td>
</tr>
<tr>
<td>at(n)</td>
<td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td>
</tr>
<tr>
<td>data()</td>
<td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</td>
</tr>
<tr>
<td>fill(val)</td>
<td>将 val 这个值赋值给容器中的每个元素。</td>
</tr>
<tr>
<td>array1.swap(array2)</td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="deque-shuang-duan-dui-lie">deque - 双端队列</h3>
<h4 id="strong-gai-nian-strong"><strong>概念</strong></h4>
<ul>
<li>所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作</li>
<li>vector 虽然也能在头尾插入元素，但是在头部插入元素的效率很低，需要大量进行移位操作</li>
</ul>
<img src="/2022/05/18/STL%E5%89%96%E6%9E%90/image-20220518143204149.png" alt="image-20220518143204149" style="zoom:80%;">
<h4 id="deque-rong-qi-he-vector-zui-da-de-chai-yi">deque 容器和 vector 最大的差异</h4>
<ul>
<li>deque 允许使用常数项时间在头部插入或删除元素</li>
<li>deque 没有容量（capacity）的概念，因为它是由动态的分段连续空间组合而成，随时可以增加一块新的空间并链接起来。因此没必要保留（reserve）功能</li>
</ul>
<p>虽然deque也提供了 Random Access Iterator，但其实现相比于vector要复杂得多，所以需要随机访问的时候最好还是用vector。</p>
<blockquote>
<p>对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector身上，将vector排序后（利用STL sort算法），再复制回deque</p>
</blockquote>
<h4 id="shi-xian-yuan-li">实现原理</h4>
<img src="/2022/05/18/STL%E5%89%96%E6%9E%90/346.jpg" alt="346" style="zoom:80%;">
<blockquote>
<p>deque 采用一块所谓的<em>map</em>作为主控。deque内部有一个指针指向<em>map</em>，<em>map是</em>一小块连续空间，其中的每个元素称为一个节点node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes</p>
</blockquote>
<p><strong>deque 的数据结构</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//指向map指针的指针</span></span><br><span class="line">    map_pointer map;<span class="comment">//指向map</span></span><br><span class="line">    size_type map_size;<span class="comment">//map的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">itertator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实现遍历 deque 容器的功能，deque 迭代器定义了如下的结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    T* cur;<span class="comment">//迭代器所指缓冲区当前的元素</span></span><br><span class="line">    T* first;<span class="comment">//迭代器所指缓冲区第一个元素</span></span><br><span class="line">    T* last;<span class="comment">//迭代器所指缓冲区最后一个元素</span></span><br><span class="line">    map_pointer node;<span class="comment">//指向管控中心map中的node</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，迭代器内部包含 4 个指针，它们各自的作用为：</p>
<ul>
<li>cur：指向当前正在遍历的元素；</li>
<li>first：指向当前连续空间的首地址；</li>
<li>last：指向当前连续空间的末尾地址；</li>
<li>node：它是一个二级指针，用于指向 map 数组中存储的指向当前连续空间的指针。</li>
</ul>
<p>迭代器的前进和后退需要注意的是，一旦行进遇到缓冲区边缘，需要特别当心，视前进或后退而定，可能需要调用<code>set_node()</code>跳一个缓冲区</p>
<h4 id="deque-chang-yong-api">deque 常用API</h4>
<ul>
<li>构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt; deqT; <span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end); <span class="comment">// 构造函数将[beg, end)区间中的元素拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> n, T elem); <span class="comment">// 构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque&amp; deq); <span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>赋值操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end); <span class="comment">// 将[beg, end)区间中的元素拷贝赋值给本身</span></span><br><span class="line"><span class="built_in">assign</span>(<span class="type">int</span> n, T elem); <span class="comment">// 将n个元素elem拷贝赋值给本身</span></span><br><span class="line"></span><br><span class="line">deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> deque&amp; deq); <span class="comment">// 重载赋值操作符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(deq); <span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大小操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 返回容器中元素的个数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>; <span class="comment">// 判断容器是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> num)</span></span>; </span><br><span class="line"><span class="comment">// 重新指定容器的长度为num，若容器变长，则以默认值填充新位置，</span></span><br><span class="line"><span class="comment">// 如果容器变短，则末尾超出容器长度的元素被删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> num, T elem)</span></span>;</span><br><span class="line"><span class="comment">// 重新指定容器的长度为num，若容器变长，则以elem填充新位置，</span></span><br><span class="line"><span class="comment">// 如果容器变短，则末尾超出容器长度的元素被删除</span></span><br></pre></td></tr></table></figure>
<ul>
<li>双端插入和删除操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(T elem); <span class="comment">// 在容器尾部添加一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(T elem); <span class="comment">// 在容器头部插入一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pop_back</span>(); <span class="comment">// 删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>(); <span class="comment">// 删除容器第一个数据</span></span><br></pre></td></tr></table></figure>
<p>在尾插时只剩一个元素备用空间时，<code>push_back()</code>调用<code>push_back_aux()</code>，先配置一块新的缓冲区，再谈妥新元素内容，然后更迭迭代器<code>finish</code>的状态</p>
<p>在头插时，第一缓冲区若无备用空间，会调用<code>push_front_aux()</code>配置一块新的缓冲区，设定新元素，更改start的状态</p>
<p>**注意：**头插尾插调用<code>push_front_aux()</code>和<code>push_back_aux()</code>时，再配置缓冲区之前，会先调用<code>reserve_map_at_front()</code>和<code>reserve_map_at_back()</code>来判断检查<em>map</em>是否需要整治（<em>map</em>节点备用空间不足），实际操作由<code>reallocate_map()</code>执行。</p>
<ul>
<li>数据存取</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> idx)</span></span>; <span class="comment">// 返回索引idx所指的数据，如果idx越界，抛出out_of_range异常</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> idx); <span class="comment">// 返回索引idx所指的数据，如果idx越界，运行直接报错</span></span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>; <span class="comment">// 返回首元素的引用</span></span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>; <span class="comment">// 返回尾元素的引用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>插入和删除操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">insert</span><span class="params">(const_iterator pos, T elem)</span></span>; </span><br><span class="line"><span class="comment">// 在pos位置处插入元素elem的拷贝，返回新数据的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator pos, <span class="type">int</span> n, T elem)</span></span>; </span><br><span class="line"><span class="comment">// 在pos位置插入n个元素elem，无返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(pos, beg, end)</span></span>;</span><br><span class="line"><span class="comment">// 将[beg, end)区间内的元素插到位置pos，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>(); <span class="comment">// 移除容器的所有数据</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator beg, iterator end)</span></span>;</span><br><span class="line"><span class="comment">// 删除区间[beg, end)的数据，返回下一个数据的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span>；</span></span><br><span class="line"><span class="function"><span class="comment">// 删除pos位置的数据，返回下一个数据的位置</span></span></span><br></pre></td></tr></table></figure>
<p><code>insert()</code>函数在某个位置插入一个元素并设定其值，如果插入点是deque前端则交给push_front()去做，如果插入点是deque后端则交给<code>push_back()</code>去做，否则交给<code>insert_aux()</code>去做；</p>
<p><code>insert_aux()</code>逻辑是比较插入点之前还是插入点之后的元素个数多，选择忘元素个数少的方向移动。</p>
<hr>
<h3 id="stack-zhan">stack - 栈</h3>
<p>stack 是一种先进后出（First In Last Out, FILO）的数据结构，它只有一个出口。</p>
<p>stack 容器允许新增元素、移除元素、取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。</p>
<blockquote>
<p>stack不允许遍历行为，因此也没有迭代器</p>
</blockquote>
<p>SGI STL默认以deque作为stack的底层结构，封闭其开端开口。因此实际上STL stack往往不被归类为container（容器），而被归类为container adapter（配接器）。</p>
<p>除deque外，list也是双向开口的数据结构，以list作为底层结构并封闭其开端开口，一样能够轻易形成stack。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;T, list&lt;T&gt; &gt; stk;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="queue-dui-lie">queue - 队列</h3>
<p>queue 是一种先进先出(First In First Out, FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素</p>
<blockquote>
<p>只有queue的顶端元素，才有机会被外界去用。queue不提供遍历功能，也不提供迭代器。</p>
</blockquote>
<p>SGI STL默认以deque作为queue的底层结构，封闭其底端出口和前端入口。queue同样归类为adapter（配接器）。queue同样可以使用list作为底层结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;T, list&lt;T&gt; &gt; que;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="heap-dui">heap - 堆</h3>
<blockquote>
<p>heap并不是STL的容器或者配接器，但却是priority queue的底层实现。并且heap运用的是常用的最大堆以及堆排序的方法</p>
</blockquote>
<ul>
<li>heap的数据结构是一个最大堆，最大堆就是一个<strong>完全二叉树</strong>，并且每个父节点都大于它的子节点（左右子节点的大小没有限制，不需要大的子节点一定要放哪边）</li>
<li>隐式表示法就是一个二叉树，可以用一个<strong>数组</strong>来表示</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(ia, ia + <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="built_in">make_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">    for_each(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123;cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//9 5 8 3 4 0 2 3 1 </span></span><br><span class="line">    </span><br><span class="line">    ivec.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">push_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">    for_each(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123;cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//9 7 8 3 5 0 2 3 1 4 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pop_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">    for_each(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123;cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    ivec.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//8 7 4 3 5 0 2 3 1 9</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">    for_each(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123;cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    <span class="comment">//0 1 2 3 3 4 5 7 8 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果heap底层使用array完成，array无法动态改变大小，因此不可以对满载的array进行<code>push_heap()</code>操作。否则会将最后一个元素视为新增元素，并将其余元素视为一个完整的heap结构。</p>
<hr>
<h3 id="priority-queue-you-xian-dui-lie">priority_queue - 优先队列</h3>
<p>优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个<strong>堆</strong>实现的，默认情况下利用一个max-heap完成，后者是一个vector表现的完全二叉树。</p>
<p>priority_queue同样是container adapter（配接器），提供的api操作与队列基本相同，也没有迭代器。</p>
<h4 id="ding-yi">定义</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Type, Container, Functional&gt; name；</span><br><span class="line"><span class="comment">//Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>对于**sort()**函数，传入的第三个参数如果是greater<int>()，则为降序；对于priority_queue，传入的第三个参数如果是greater<int>，为小顶堆。</int></int></p>
<p>其实在优先队列中，greater是判断父节点是否比子节点值都大，是则swap。</p>
</blockquote>
<h4 id="pai-xu-1">排序</h4>
<ul>
<li>
<p>Type为pair</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自定义比较顺序</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="comment">//重载()操作符</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &lt; b.second || (a.second == b.second &amp;&amp; a.first &gt; b.first);</span><br><span class="line">               &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int,int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; a;</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;, cmp&gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">e</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    a.<span class="built_in">push</span>(e);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>还可以这样写（使用lambda表达式)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.first + a.second &lt; b.first + b.second;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">que</span>(cmp);</span><br><span class="line"></span><br><span class="line">que.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(nums1[i], nums2[j]))；</span><br></pre></td></tr></table></figure>
<p>也可以这样写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &lt; nums1[b.first] + nums2[b.second];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">que</span>(cmp);</span><br><span class="line"></span><br><span class="line">que.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(i, j))；</span><br><span class="line"><span class="comment">//优先队列中存的是下标</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="slist-dan-xiang-lian-biao">slist - 单向链表</h3>
<p>STL中list是双向链表，而slist是单向链表。</p>
<p><strong>区别</strong>是slist的迭代器是单向的Forward Iterator，而list的迭代器是双向的Bidirectional Iterator。slist所耗用的空间更小，操作更快。它们<strong>共同的特点</strong>是，插入、移除、接合等操作并不会造成原有的迭代器失效。</p>
<p>slist插入时，需要从前遍历，找到插入点的位置。为了更快插入，提供了<code>insert_after()</code>，<code>erase_after()</code>。slist提供<code>push_front()</code>，不提供<code>push_back()</code>操作，故其元素次序与元素插入顺序相反。</p>
<p>slisi的迭代器如图所示</p>
<img src="/2022/05/18/STL%E5%89%96%E6%9E%90/image-20220518192817133.png" alt="image-20220518192817133" style="zoom:80%;">
<h4 id="shu-ju-jie-gou">数据结构</h4>
<p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allco</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> slist</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> list_node* <span class="built_in">create_node</span>(<span class="type">const</span> value_type&amp; x)&#123;&#125;<span class="comment">//配置空间、构造元素</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="built_in">destroy_node</span>(list_node* node)&#123;&#125;<span class="comment">//析构函数、释放空间</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list_node_base head; <span class="comment">//头部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(slist&amp; L)</span></span>&#123;&#125;<span class="comment">//交换两个slist，只需要换head即可</span></span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//取头部元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value&amp; x)</span></span>&#123;&#125;<span class="comment">//头部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//从头部取走元素</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是C++标准委员会没有采用slist的名称，forward_list在C++ 11中出现，它与slist的区别是没有<code>size()</code>方法。</p>
<hr>
<h2 id="guan-lian-shi-rong-qi">关联式容器</h2>
<p>所谓关联式容器，观念上类似于关联式数据库：每个元素都有一个键值(key)和实值(value)。</p>
<h3 id="pair-yuan-zu">pair - 元组</h3>
<p>考虑到<code>&lt;key,value&gt;</code>键值对这一特殊形式，STL封装了一个名为pair的模板，其包括first和second两个元素形成一个二元组<code>&lt;first, second&gt;</code></p>
<h4 id="ding-yi-he-chu-shi-hua">定义和初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>定义一个空pair</span><br><span class="line">pair&lt;T1,T2&gt; p;</span><br><span class="line"><span class="number">2.</span>调用构造函数</span><br><span class="line"><span class="function">pair&lt;T1,T2&gt; <span class="title">p</span><span class="params">(first,second)</span></span>;</span><br><span class="line"><span class="number">3.</span>调用拷贝构造函数</span><br><span class="line"><span class="function">pair&lt;T1,T2&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"><span class="number">4.</span>调用移动构造函数</span><br><span class="line"><span class="function">pair&lt;T1,T2&gt; <span class="title">p</span><span class="params">(make_pair(first,second))</span></span>;</span><br><span class="line"><span class="number">5.</span>调用右值引用</span><br><span class="line"><span class="function">pair&lt;T1,T2&gt; <span class="title">p</span><span class="params">((T1)first,(T2)second)</span></span>;</span><br><span class="line"><span class="number">6.</span>初始化成员列表</span><br><span class="line">pair&lt;T1,T2&gt; p&#123;first,second&#125;;或pair&lt;T1,T2&gt; p = &#123;first,second&#125;;</span><br><span class="line">    </span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;<span class="comment">//一个空pair，其first和second默认初始化为0</span></span><br><span class="line">cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;<span class="comment">//0 0</span></span><br><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;stl&quot;</span>, <span class="string">&quot;yyds&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p2.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2.second &lt;&lt; endl;<span class="comment">//stl yyds</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;</span><br><span class="line">cout &lt;&lt; p4.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p4.second &lt;&lt; endl;<span class="comment">//1 2</span></span><br><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">p5</span><span class="params">(make_pair(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; p5.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p5.second &lt;&lt; endl;<span class="comment">//hello world</span></span><br><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">p6</span><span class="params">((string)<span class="string">&quot;happy&quot;</span>, (string)<span class="string">&quot;day&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p6.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p6.second &lt;&lt; endl;<span class="comment">//happy day</span></span><br></pre></td></tr></table></figure>
<h4 id="cheng-yuan-han-shu-1">成员函数</h4>
<p>pair允许对pair对象进行比较操作，包括&gt; &lt; &gt;= &lt;= == !=在比较时，首先比较first元素，然后再比较second元素。注意在比较的时候两个pair的T1与T2类型要<strong>严格一致</strong>，其不支持自动类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (p &lt; p2) &#123;<span class="comment">//error</span></span><br><span class="line">    cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="set-ji-he">set - 集合</h3>
<blockquote>
<p>红黑树（RB-tree）</p>
</blockquote>
<p>红黑树是一颗二叉搜索树，同时满足以下规则：</p>
<ul>
<li>每个节点非红即黑</li>
<li>根节点为黑</li>
<li>红节点的子节点为黑</li>
<li>任何节点到NULL（树尾端）的任何路径，所含黑节点个数相同（黑高度相同）</li>
</ul>
<h4 id="gai-nian-2">概念</h4>
<p>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值</p>
<p>set不允许迭代器修改元素的值，其迭代器是一种constance iterators</p>
<p>标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为</p>
<h4 id="chang-yong-api">常用API</h4>
<ul>
<li>创建和初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*下列初始化都会给出默认排序，实际中可以不写，默认调用std::less&lt;T&gt;，可以根据需要编写自定义的比较</span><br><span class="line"><span class="number">1.</span>直接创建一个空的set</span><br><span class="line">set&lt;T,std::less&lt;T&gt;&gt; s;</span><br><span class="line"><span class="number">2.</span>初始化成员列表</span><br><span class="line">set&lt;T,std::less&lt;T&gt;&gt; s&#123;value1,value2...&#125;;</span><br><span class="line"><span class="number">3.</span>拷贝构造函数</span><br><span class="line">set&lt;T,std::less&lt;T&gt;&gt; s1;</span><br><span class="line">set&lt;T,std::less&lt;T&gt;&gt; <span class="built_in">s</span>(s1);<span class="comment">//T与比较函数必须一致</span></span><br><span class="line"><span class="number">4.</span>借助已有set容器指定的区间来定义及初始化</span><br><span class="line">set&lt;T,std::less&lt;T&gt;&gt; <span class="built_in">s1</span>(value1,value2);</span><br><span class="line">set&lt;T,std::less&lt;T&gt;&gt; <span class="built_in">s2</span>(++s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>());<span class="comment">//包括了&#123;value2&#125;的一个set容器</span></span><br><span class="line"><span class="number">5.</span>修改set容器的排序规则</span><br><span class="line">  <span class="number">1.</span>调用默认的greater进行降序</span><br><span class="line">  set&lt;T,std::greater&lt;T&gt;&gt; s;</span><br><span class="line">  <span class="number">2.</span>自定义</span><br><span class="line">      </span><br><span class="line"><span class="comment">//一个空set</span></span><br><span class="line">set&lt;<span class="type">int</span>,less&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line"><span class="comment">//初始化成员列表</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s4&#123; <span class="number">10</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s2</span>(s);<span class="comment">//error 比较函数不一致</span></span><br><span class="line">set&lt;<span class="type">int</span>, less&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s3</span>(s);<span class="comment">//accept!</span></span><br><span class="line"><span class="comment">//set容器区间</span></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s6</span><span class="params">(++s4.begin(), s4.end())</span></span>;</span><br><span class="line"><span class="comment">//修改set容器的排序规则</span></span><br><span class="line">set&lt;<span class="type">int</span>, std::greater&lt;<span class="type">int</span>&gt;&gt; s7;</span><br></pre></td></tr></table></figure>
<ul>
<li>增删操作</li>
</ul>
<p>与map不同，set中数据只能通过<code>insert()</code>函数进行插入。</p>
<p>从set中删除元素使用到的函数是erase()函数，主要有以下的几种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">• <span class="built_in">insert</span>(x);<span class="comment">//当容器中没有等价元素的时候，将元素 x 插入到 set 中</span></span><br><span class="line">• <span class="built_in">erase</span>(x); <span class="comment">//删除值为 x 的 所有 元素，返回删除元素的个数。</span></span><br><span class="line">• <span class="built_in">erase</span>(pos);<span class="comment">//删除迭代器为 pos 的元素，要求迭代器必须合法</span></span><br><span class="line">• <span class="built_in">erase</span>(b, e);<span class="comment">//删除迭代器在 [b, e) 范围内的所有元素</span></span><br><span class="line">• <span class="built_in">clear</span>();<span class="comment">//清空 set</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查找操作</li>
</ul>
<p>面对关联式容器，应该使用其所提供的<code>find</code>函数来搜寻元素，会比使用STL算法<code>find()</code>更有效率。因为STL算法<code>find()</code>只是循序搜寻。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">• <span class="built_in">count</span>(x);<span class="comment">//返回set内键为x的元素数量。</span></span><br><span class="line">• <span class="built_in">find</span>(x);<span class="comment">//在set内存在键为x的元素时会返回该元素的迭代器，否则返回end()</span></span><br><span class="line">• <span class="built_in">lower_bound</span>(x);<span class="comment">//返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回end()</span></span><br><span class="line">• <span class="built_in">upper_bound</span>(x);<span class="comment">//返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回end()</span></span><br><span class="line">• <span class="built_in">empty</span>();<span class="comment">//返回容器是否为空。</span></span><br><span class="line">• <span class="built_in">size</span>();<span class="comment">//返回容器内元素个数。</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="multiset-duo-zhong-ji-he">multiset - 多重集合</h3>
<p>和 set 容器十分相似，唯一的区别在于，multiset 容器中可以同时存储多（≥2）个键相同的键值对。</p>
<p>需要注意的是，不建议直接修改 multiset 容器的值，因为对于一个 multiset 容器来说，其内部的元素的key与value是相等的，直接修改可能会破坏其排序顺序，因此最好是先删除再添加。</p>
<p><code>multimap</code>和<code>map</code>的唯一区别就是：multimap调用的是红黑树的<code>insert_equal()</code>,可以重复插入而map调用的则是独一无二的插入<code>insert_unique()</code>，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。</p>
<p>初始化方式与set并无二致</p>
<hr>
<h3 id="map-ying-she">map - 映射</h3>
<p>map的是C++中存储键值对的数据结构。很多情况下，map中存储的键值对通过pair向外暴露。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">double</span>&gt; mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2.0</span>));</span><br></pre></td></tr></table></figure>
<p>map一般存储的都是pair对象，当存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则。除此之外，我们可以手动指定 map 容器的排序规则，既可以选用 STL 标准库中提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>），也可以自定义排序规则。</p>
<p><strong>另外，对于map容器来说，其键（key）是一个被加了const修饰的值，不能被修改，更不能重复，但是value是一个可以被修改的值，并且多个key可以同时对应一个value</strong></p>
<h4 id="chang-yong-api-1">常用API</h4>
<ul>
<li>构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;T1, T2&gt; mapTT; <span class="comment">// map默认构造函数</span></span><br><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map&amp; mp); <span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>赋值操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map&amp; mp); <span class="comment">// 重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(mp); <span class="comment">// 交换两个集合容器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大小操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 返回容器中元素的数目</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>; <span class="comment">// 判断容器是否为空</span></span><br></pre></td></tr></table></figure>
<ul>
<li>插入删除操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;T1, T2&gt; p)</span></span>; <span class="comment">// 通过pair的方式插入对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 参数部分可以用pair的构造函数创建匿名对象</span></span><br><span class="line"><span class="comment">2. 也可以使用make_pair创建pair对象</span></span><br><span class="line"><span class="comment">3. 还可以用map&lt;T1, T2&gt;::value_type(key, value)来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">T2&amp; <span class="keyword">operator</span>[](T1 key); <span class="comment">// 通过下标的方式插入值</span></span><br><span class="line"><span class="comment">// 如果通过下标访问新的键却没有赋值，会自动用默认值填充</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 删除所有元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>; <span class="comment">// 删除pos迭代器所指的元素，返回下一个元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(beg, end)</span></span>; <span class="comment">// 删除区间[beg, end)内的所有元素，返回下一个元素的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(keyElem); <span class="comment">// 删除容器中key为keyElem的对组</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查找操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(T1 key)</span></span>; </span><br><span class="line"><span class="comment">// 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(T1 keyElem)</span></span>;</span><br><span class="line"><span class="comment">// 返回容器中key为keyElem的对组个数，对map来说只可能是0或1，对于multimap可能大于1</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(T keyElem)</span></span>;</span><br><span class="line"><span class="comment">// 返回第一个key&gt;=keyElem元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(T keyElem)</span></span>;</span><br><span class="line"><span class="comment">// 返回第一个key&gt;keyElem元素的迭代器</span></span><br><span class="line"><span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(T keyElem)</span></span>;</span><br><span class="line"><span class="comment">// 返回容器中key与keyElem上相等的两个上下限迭代器</span></span><br></pre></td></tr></table></figure>
<h4 id="pai-xu-2">排序</h4>
<ul>
<li><strong>对key值进行特定的排序</strong></li>
</ul>
<p>map容器里面有两个值一个key一个是value，map&lt;key,value&gt;，其实map里面还有第三个参数，是一个类，用来对map的<strong>key</strong>进行排序的类</p>
<p>写出一个greater类来让key按照降序排列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; PAIR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">greater</span>&#123;   </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;  _Left, <span class="type">const</span> string&amp;  _Right)</span> <span class="type">const</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> (_Left  &gt;  _Right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>, greater&gt; ma;</span><br><span class="line">    ma[<span class="string">&quot;Alice&quot;</span>] = <span class="number">86</span>;</span><br><span class="line">    ma[<span class="string">&quot;Bob&quot;</span>] = <span class="number">78</span>;</span><br><span class="line">    ma[<span class="string">&quot;Zip&quot;</span>] = <span class="number">92</span>;</span><br><span class="line">    ma[<span class="string">&quot;Stdevn&quot;</span>] = <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;string, <span class="type">int</span>&gt;::iterator ite = ma.<span class="built_in">begin</span>(); ite != ma.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ite-&gt;first &lt;&lt; <span class="string">&quot;&quot;</span>&lt;&lt; ite-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Zip92</span></span><br><span class="line"><span class="comment">Stdevn88</span></span><br><span class="line"><span class="comment">Bob78</span></span><br><span class="line"><span class="comment">Alice86</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对value的值进行排序</strong></li>
</ul>
<p>因为map的模板里面没有对value的值进行排序的参数，所以只能借助<code>sort</code>函数，然而sort函数只能对vector，list，queue等排序，无法对map排序，那么就需要把map的值放入vector中在对vector进行排序，在对vector进行输出，从而间接实现了对map的排序。sort也有第三个参数，跟上面那个map类似，所以可以写一个类或者函数来将其排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; PAIR;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_val</span><span class="params">(<span class="type">const</span> PAIR&amp; left, <span class="type">const</span> PAIR&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left.second &lt; right.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; ma;</span><br><span class="line">    ma[<span class="string">&quot;Alice&quot;</span>] = <span class="number">86</span>;</span><br><span class="line">    ma[<span class="string">&quot;Bob&quot;</span>] = <span class="number">78</span>;</span><br><span class="line">    ma[<span class="string">&quot;Zip&quot;</span>] = <span class="number">92</span>;</span><br><span class="line">    ma[<span class="string">&quot;Stdevn&quot;</span>] = <span class="number">88</span>;</span><br><span class="line">    <span class="function">vector&lt;PAIR&gt; <span class="title">vec</span><span class="params">(ma.begin(), ma.end())</span></span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp_val);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;PAIR&gt;::iterator ite = vec.<span class="built_in">begin</span>(); ite != vec.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ite-&gt;first &lt;&lt; <span class="string">&quot;\t&quot;</span>&lt;&lt; ite-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Bob     78</span></span><br><span class="line"><span class="comment">Alice   86</span></span><br><span class="line"><span class="comment">Stdevn  88</span></span><br><span class="line"><span class="comment">Zip     92</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者通过lambda表达式</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),[](<span class="type">const</span> PAIR &amp;left, <span class="type">const</span> PAIR &amp;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> left.second &lt; right.second;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="multimap-duo-zhong-ying-she">multimap - 多重映射</h3>
<p>和 map 容器十分相似，唯一的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。</p>
<hr>
<h3 id="hashtable-ha-xi-biao">hashtable - 哈希表</h3>
<h4 id="gai-nian-3">概念</h4>
<p>基本原理是：使用一个下标范围比较大的数组来存储元素。把关键字Key通过一个固定的算法函数即所谓的哈希函数（散列函数）转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的list空间里。也可以简单的理解为，按照关键字key为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。</p>
<p>为了避免哈希表太大，需要用到某种映射函数，将大数映射为小数，这种函数称为散列函数hash function。但hash function会带来碰撞问题，即不同的元素被映射到相同位置</p>
<p>为了解决碰撞问题的方法有：线性探测、二次探测、再散列、开链法。</p>
<ul>
<li>线性探测 – 使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</li>
<li>再散列 – 发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</li>
<li>开链 –  每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</li>
<li>二次探测 – 使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</li>
</ul>
<p>线性探测法容易产生<strong>主集团(primary clustering)</strong>，二次探测法可能造成<strong>次集团(secondary clustering)</strong> 问题。</p>
<h4 id="yuan-li">原理</h4>
<p>hashtable就是用的<strong>开链法</strong>，使用开链法，表格的负载系数将大于1。</p>
<p>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的<code>linked-list</code>，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作。</p>
<p>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。</p>
<p><strong>如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。</strong></p>
<img src="/2022/05/18/STL%E5%89%96%E6%9E%90/523.png" alt="523" style="zoom:80%;">
<p><strong>hashtable节点及迭代器的定义</strong></p>
<p><img src="/2022/05/18/STL%E5%89%96%E6%9E%90/435634.png" alt="435634"></p>
<p>迭代器类型是 <strong>forward_iterator_tag (前向迭代器)</strong>，hashtable的迭代器没有后退操作（<code>operator--()</code>），也没有定义所谓的逆向迭代器（<code>reverse iterator</code>）。</p>
<h4 id="cao-zuo">操作</h4>
<p>hashtable 的插入 跟 RB-tree 的插入类似，有两种插入方法 <code>insert_unique()</code> 和 <code>insert_equal()</code> ，意思也是一样的，<code>insert_unique()</code> 不允许有重复值，而 <code>insert_equal()</code> 允许有重复值。插入时会判断是否需要重建表格。</p>
<blockquote>
<p>判断 “表格重建与否” 是拿元素个数（把新增元素计入后）和 bucket vector 的大小来比，如果前者大于后者，就重建表格 。所以 每个 bucket list 的最大容量和 bucket vector 的大小相同</p>
</blockquote>
<ul>
<li>
<p><code>insert_unique()</code> 函数，需要注意的是插入时，新节点直接插入到链表的头节点</p>
</li>
<li>
<p>允许重复插入的 <code>insert_equal()</code>，需要注意的是插入时，重复节点插入到相同节点的后面，新节点还是插入到链表的头节点</p>
</li>
</ul>
<p>注意：<strong>hashtable 中，键值相同的元素，一定落在同一个 bucket list 中，但是并不排序</strong></p>
<h4 id="wu-xu-guan-lian-shi-rong-qi">无序关联式容器</h4>
<p>自 C++11 标准起，四种基于哈希实现的无序关联式容器正式纳入了 C++ 的标准模板库中，分别是：</p>
<p><strong><code>unordered_set</code>，<code>unordered_multiset</code>，<code>unordered_map</code>，<code>unordered_multimap</code></strong></p>
<p>都以hashtable为底层结构</p>
<p>采用哈希存储的特点使得无序关联式容器 <strong>在平均情况下</strong> 大多数操作（包括查找，插入，删除）都能在常数时间复杂度内完成，相较于关联式容器与容器大小成对数的时间复杂度更加优秀。</p>
<p><strong>在最坏情况下</strong>，对无序关联式容器进行插入、删除、查找等操作的时间复杂度会 <strong>与容器大小成线性关系</strong>！这一情况往往在容器内出现大量哈希冲突时产生。</p>
<p>因此应谨慎使用无序关联式容器，尽量避免滥用（例如懒得离散化，直接将 <code>unordered_map&lt;int, int&gt;</code> 当作空间无限的普通数组使用）</p>
<hr>
<h1 id="suan-fa">算法</h1>
<p>STL算法的一般形式-泛型算法。所有泛型算法的前两个参数都是一对迭代器，通常称为first，last，以标示算法的操作区间，前闭后开。这个[first,last)区间的必要条件是，必须能够经由increment（累加）操作的反复运用，从first到last。编译器本生无法强求这一点，如果这个条件不成立，会导致未可预期的后果</p>
<h2 id="zhi-du-suan-fa">只读算法</h2>
<ul>
<li>查找算法</li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>find(beg, end, v)</td>
<td>在迭代区间[beg, end)内查找等于v的元素，找到并返回对应的迭代器，否则返回end</td>
</tr>
<tr>
<td>find_first_of(beg, end, beg2, end2)</td>
<td>在迭代区间[beg, end)内查找与区间[beg2, end2)内任意元素匹配的元素，然后返回一个迭代器，指向第一个匹配的元素。如果找不到元素，则返回第一个范围的end迭代器</td>
</tr>
<tr>
<td>find_end(beg, end, beg2, end2)</td>
<td>与find_first_of类似，查找最后一个匹配的元素</td>
</tr>
<tr>
<td>find_if(beg, end, func)</td>
<td>函数find的带一个函数参数的_if版本，与find功能相同，条件：使函数func返回true</td>
</tr>
</tbody>
</table>
<ul>
<li>搜索与统计算法</li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>search(beg, end, beg2, end2)</td>
<td>在迭代区间[beg, end)内查找子序列[beg2, end2)</td>
</tr>
<tr>
<td>search_n(beg, end,n, v)</td>
<td>在迭代区间[beg, end)内查找连续n个元素v</td>
</tr>
<tr>
<td>binary_search(beg, end, v)</td>
<td>试图在已排序的[first, last)中二分查找元素v，找到返回true，否则返回false。</td>
</tr>
<tr>
<td>count(beg, end, v)</td>
<td>统计迭代区间[beg, end)内等于v的元素个数</td>
</tr>
<tr>
<td>count_if(beg, end, func)</td>
<td>函数count的_if版本</td>
</tr>
<tr>
<td>lower_bound(beg, end, v)</td>
<td>进行二分查找非递减序列内第一个大于等于 x 的数的地址/迭代器</td>
</tr>
<tr>
<td>upper_bound(beg, end, v)</td>
<td>进行二分查找非递减序列内第一个大于 x 的数的地址/迭代器</td>
</tr>
<tr>
<td>accumulate(beg, end, v)</td>
<td>累加求和，头两个形参指定要累加的元素范围，第三个形参则是累加的初值，其返回类型就是其第三个实参的类型</td>
</tr>
</tbody>
</table>
<h2 id="ke-bian-xu-lie-suan-fa">可变序列算法</h2>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy(beg, end, beg2)</td>
<td>将迭代器区间[beg, end)元素复制到以beg2开始的区间</td>
</tr>
<tr>
<td>transform(beg, end, beg2, func)</td>
<td>功能同上，只是每个元素需要经过函数func处理</td>
</tr>
<tr>
<td>replace(beg, end, v1, v2)</td>
<td>将迭代器区间[beg, end)内等于v1的元素替换为v2</td>
</tr>
<tr>
<td>fill(beg, end, v)</td>
<td>区间内元素都写入v</td>
</tr>
<tr>
<td>fill_n(beg, n, v)</td>
<td>从位置beg开始的n元素写入v</td>
</tr>
<tr>
<td>generate(beg, n, rand)</td>
<td>向从beg开始的n个位置随机填写数据</td>
</tr>
<tr>
<td>remove(beg, end)</td>
<td>移除区间[beg, end)内的元素。注意：并不真正删除</td>
</tr>
<tr>
<td>unique(beg, end)</td>
<td>剔除相邻重复的元素。注意：并不真正删除</td>
</tr>
<tr>
<td>iota(beg, end, T)</td>
<td>用连续的 T 类型值填充序列。前两个参数是定义序列的正向迭代器，第三个参数是初始的 T 值</td>
</tr>
</tbody>
</table>
<p>copy，transform，fill_n和generat都需要保证：输出序列有足够的空间。</p>
<p>删除函数并不真正删除元素，只是将要删除的元素移动到容器的末尾，删除元素需要容器擦除函数来操作。同理，独特的函数也不会改变容器的大小，只是这些元素的顺序改变了，是将无重复的元素复制到序列的前端，从而覆盖相邻的重复元素.unique返回的迭代器指向超出无重复的元素范围末端的下一位置</p>
<h2 id="pai-xu-suan-fa">排序算法</h2>
<p>STL的sort算法，数据量大时采用快速排序来分段递归排序。一旦分段后的数量小于某个门槛（定义为16），为避免快排的递归调用带来过大的额外负担，就改用插入排序，如果递归层次过深，还会改用堆排序。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort(beg, end)</td>
<td>区间[beg, end)内元素按照字典序排列</td>
</tr>
<tr>
<td>stable_sort(beg, end, func)</td>
<td>同上，不过保存相等元素之间的顺序关系</td>
</tr>
<tr>
<td>partial_sort(beg, mid, end)</td>
<td>将最小的元素顺序放在[beg, mid)内</td>
</tr>
<tr>
<td>random_shuffle(beg, end)</td>
<td>区间内元素随机排序</td>
</tr>
<tr>
<td>reverse(beg, end)</td>
<td>将区间内元素反转</td>
</tr>
<tr>
<td>rotate(beg, mid, end)</td>
<td>将区间[beg, mid)和[mid, end)旋转，使mid作为新的起点</td>
</tr>
<tr>
<td>merge(beg, end, beg2, end2, nbeg)</td>
<td>将有序区间[beg, end)和[beg2, end2)合并到一个新的序列nbeg中，并对其排序</td>
</tr>
</tbody>
</table>
<h2 id="guan-xi-suan-fa">关系算法</h2>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>equal(beg, end, beg2, end2)</td>
<td>判断两个区间元素是否相等</td>
</tr>
<tr>
<td>includes(beg, end, beg2, end2)</td>
<td>判断[beg, end)序列是否被第二个序列[beg2, end2)包含</td>
</tr>
<tr>
<td>max_element(beg, end)</td>
<td>返回序列最大元素所在迭代器</td>
</tr>
<tr>
<td>min_element(beg, end)</td>
<td>返回序列最小元素所在迭代器</td>
</tr>
<tr>
<td>mismatch(beg, end, beg2, end2)</td>
<td>查找两个序列中第一个不匹配的元素，返回一对迭代器，标记第一个不匹配元素的位置</td>
</tr>
</tbody>
</table>
<h2 id="dui-suan-fa">堆算法</h2>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>make_heap(beg, end)</td>
<td>以区间[beg, end)内元素建立堆</td>
</tr>
<tr>
<td>pop_heap(beg, end)</td>
<td>重新排序堆，使第一个元素与最后一个交换，并不真正弹出最大值</td>
</tr>
<tr>
<td>push_heap(beg, end)</td>
<td>重新排序堆，把新元素放在最后一个位置</td>
</tr>
<tr>
<td>sort_heap(beg, end)</td>
<td>对序列重新排序</td>
</tr>
</tbody>
</table>
<h2 id="rong-qi-te-you-suan-fa">容器特有算法</h2>
<ul>
<li>list相关算法</li>
</ul>
<p>list容器上的迭代器是双向的，而不是随机访问类型。因此，在此容器上不能使用需要随机访问迭代器的算法。这些算法包括sort及其相关的算法。还有一些其他的泛型算法，如合并，删除，反向和唯一，虽然可以用在列上，但却付出了性能上的代价。如果这些算法利用列表容器实现的特点，则可以更高效地执行。</p>
<p>标准库为list容器定义了更精细的操作集合，使它不必只依赖于泛型操作。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lst.merge(lst2)</td>
<td>将lst2的元素合并到lst中。这两个容器对象都必须排序。lst2中的元素将被删除。合并后，lst2为空。使用<code>&lt;</code>操作符比较</td>
</tr>
<tr>
<td>lst.merge(lst2， cmp)</td>
<td>同上，使用<code>cmp</code>函数比较排序</td>
</tr>
<tr>
<td>lst.remove(val)</td>
<td>调用<code>lst.erase()</code>删除所有指定值元素</td>
</tr>
<tr>
<td>lst.reverse()</td>
<td>反转lst中的元素</td>
</tr>
<tr>
<td>lst.sort()</td>
<td>对lst中的元素排序</td>
</tr>
<tr>
<td>lst.splice(iter, lst2)</td>
<td>将lst2的元素移到lst的iter所指向元素前面；合并后lst2为空，不能是同一个list</td>
</tr>
<tr>
<td>lst.splice(iter, lst2, iter2)</td>
<td>将lst2中iter2所指向的元素移到lst的iter前面；可以是同一个list</td>
</tr>
<tr>
<td>lst.splice(iter,beg, end)</td>
<td>将[beg, end)内元素移动到iter前面，如果iter也指向这个区间，则不做任何处理</td>
</tr>
<tr>
<td>lst.unique()</td>
<td>调用<code>erase()</code>删除同一个值的副本。用<code>==</code>操作符比较</td>
</tr>
<tr>
<td>lst.unique(func)</td>
<td>同上，用func函数比较</td>
</tr>
</tbody>
</table>
<ul>
<li>set相关算法</li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_intersection(beg1, end1, beg2, end2, dest);</td>
<td>求两个set集合的交集，dest为目标容器开始迭代器，返回目标容器最后一个元素的迭代器地址</td>
</tr>
<tr>
<td>set_union(beg1, end1, beg2, end2, dest);</td>
<td>求两个set集合的并集，dest为目标容器开始迭代器，返回目标容器最后一个元素的迭代器地址</td>
</tr>
<tr>
<td>set_difference(beg1, end1, beg2, end2, dest);</td>
<td>求两个set集合的差集，dest为目标容器开始迭代器，返回目标容器最后一个元素的迭代器地址</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="fang-han-shu">仿函数</h1>
<h2 id="gai-nian-4">概念</h2>
<p>模仿函数的类，使用方式如同函数。本质是类中重载括弧运算符<code>operator()</code>。</p>
<ol>
<li><strong>重载函数调用操作符的类，其对象</strong>常称为<strong>函数对象(function object)</strong>，也叫<strong>仿函数(functor)</strong>，使得类对象可以像函数那样调用。</li>
<li>STL提供的算法往往有两个版本，一种是按照我们常规默认的运算来执行，另一种允许用户自己定义一些运算或操作，通常通过回调函数或模版参数的方式来实现，此时functor便派上了用场，特别是作为模版参数的时候，只能传类型。</li>
<li>函数对象超出了普通函数的概念，其内部可以拥有自己的状态(其实也就相当于函数内的static变量)，可以通过成员变量的方式被记录下来。</li>
<li>函数对象可以作为函数的参数传递。</li>
<li>函数对象通常不定义构造和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用时的运行时问题。</li>
<li>模版函数对象使函数对象具有通用性，这也是它的优势之一。</li>
<li>STL需要我们提供的functor通常只有一元和二元两种。</li>
<li>lambda 表达式的内部实现其实也是仿函数</li>
</ol>
<h2 id="nei-jian-han-shu-dui-xiang">内建函数对象</h2>
<blockquote>
<p>使用时需要包含头文件<code>&lt;functional&gt;</code></p>
</blockquote>
<p>STL 内建了一些函数对象，分为：</p>
<ul>
<li>算术类函数对象</li>
</ul>
<p>negate 是一元运算，其他都是二元运算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T plus&lt;T&gt;; <span class="comment">// 加法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T minus&lt;T&gt;; <span class="comment">// 减法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T multiplies&lt;T&gt;; <span class="comment">// 乘法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T divides&lt;T&gt;; <span class="comment">// 除法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T modulus&lt;T&gt;; <span class="comment">// 取模仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T negate&lt;T&gt;; <span class="comment">// 取反函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关系运算类函数对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> equal_to&lt;T&gt;; <span class="comment">// 等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> not_equal_to&lt;T&gt;; <span class="comment">// 不等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> greater&lt;T&gt;; <span class="comment">// 大于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> greater_equal&lt;T&gt;; <span class="comment">// 大于等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> less&lt;T&gt;; <span class="comment">// 小于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> less_equal&lt;T&gt;; <span class="comment">// 小于等于</span></span><br></pre></td></tr></table></figure>
<ul>
<li>逻辑运算类函数对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_and&lt;T&gt;; <span class="comment">// 逻辑与</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_or&lt;T&gt;; <span class="comment">// 逻辑或</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_not&lt;T&gt;; <span class="comment">// 逻辑非</span></span><br></pre></td></tr></table></figure>
<h2 id="an-li">案例</h2>
<p>仿函数作为set类的比较操作模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1） 在模板参数中添加仿函数类可以改变set升降序；</span></span><br><span class="line"><span class="comment">//(2)可以多定义几个仿函数类，用来调用主类的成员函数；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> S&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> set&lt;T,S&gt;&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n:s)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greator</span>&#123;   <span class="comment">//（1） 在模板参数中添加仿函数类可以改变set升降序；</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> string&amp; name,<span class="type">int</span> age,<span class="type">float</span> scores):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age),<span class="built_in">scores</span>(scores)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetScores</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> scores;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> Student&amp; s)&#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; s.name &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; s.scores;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeComp</span>&#123;   <span class="comment">//(2)可以多定义几个仿函数类，用来调用主类的成员函数；</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Student&amp; a,<span class="type">const</span> Student&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">GetAge</span>() &gt; b.<span class="built_in">GetAge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScoreComp</span>&#123;  <span class="comment">//(2)可以多定义几个仿函数类，用来调用主类的成员函数；</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Student&amp; a,<span class="type">const</span> Student&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">GetScores</span>() &lt; b.<span class="built_in">GetScores</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>,Greator&gt; s; <span class="comment">// 在模板参数中添加仿函数类可以改变set升降序</span></span><br><span class="line">    s = &#123;<span class="number">10</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">// 数据有序</span></span><br><span class="line">    <span class="comment">// 数据唯一</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(s);</span><br><span class="line"></span><br><span class="line">    set&lt;Student,AgeComp&gt; stu = &#123;   </span><br><span class="line">           <span class="built_in">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>,<span class="number">89</span>),</span><br><span class="line">           <span class="built_in">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">78</span>),</span><br><span class="line">           <span class="built_in">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">69</span>) </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(stu);</span><br><span class="line">    <span class="function">set&lt;Student,ScoreComp&gt; <span class="title">stu2</span><span class="params">(stu.begin(),stu.end())</span></span>;  <span class="comment">//(2)仿函数的调用：实质：重载（）运算符；</span></span><br><span class="line">    <span class="built_in">Print</span>(stu2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="pei-jie-qi">配接器</h1>
<h2 id="gai-nian-5">概念</h2>
<p>配接器正如他的名字，在STL中是一个轴承、转换器的角色。Adapter这个概念，实际上是一种设计模式。</p>
<p>在STL中，改变接口，赋予新功能，与其他classes进行兼容。主要包括仿函数配接器（function adapter）、容器配接器（container adapter）、迭代器配接器（iterator adapter）。</p>
<ul>
<li>应用于容器</li>
</ul>
<p>STL提供的两个容器queue和stack，两者是一种容器配接器，修饰了deque的接口。</p>
<p>class stack封住了所有的deque的对外接口，只开放符合stack原则的几个函数，所以说stack是一个配接器，一个作用于容器之上的配接器。</p>
<ul>
<li>应用于迭代器</li>
</ul>
<p>insert iterators 可以将一般迭代器的赋值操作转变为插入操作；<br>
reverse iterators 可以将一般迭代器的行进方向逆转，使原本应该前进的<code>operator++</code>变成了后退操作，使原本后退的<code>operator--</code>变成了前进操作；<br>
iostream iterators可以将迭代器绑定到某个iostream对象身上使其拥有输入输出功能。</p>
<ul>
<li>应用于仿函数</li>
</ul>
<p>functor adapters是所有配接器中数量最庞大的一个，可以不断配接、配接、再配接。这些配接操作包括系结、否定、组合、以及对一般成员函数的修饰（使其成为一个仿函数）。</p>
<p>function adapters的价值在于，通过它们之间的**绑定、组合、修饰能力，**几乎可以无限制地创造出各种可能的表达式，搭配STL算法一起使用。</p>
<h2 id="ke-pei-jie-de-guan-jian">可配接的关键</h2>
<p>所有期望获得配接能力的组件，本身都必须是可配接的，因此：</p>
<ul>
<li>一元仿函数必须继承自unary_function</li>
<li>二元仿函数必须继承自binary_function</li>
<li>成员函数必须以mem_fun处理过</li>
<li>一般函数必须以ptr_fun处理过。一个未经ptr_fun处理过的一般函数，虽然也可以函数指针的形式传给STL算法使用，但是却没有任何配接能力</li>
</ul>
<p><strong>案例：</strong></p>
<p>我们希望在每个数据输出的时候加上一个基值，并且该基值由用户输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span>: <span class="keyword">public</span> binary_function&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>&gt; </span><br><span class="line"><span class="comment">// 2.做继承 参数1类型 + 参数2类型 + 返回值类型 binary_function</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> base)</span> <span class="type">const</span> <span class="comment">// 3. 加const, 和父类保持一致</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val + base &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">myPrint</span>(), n)); </span><br><span class="line">    <span class="comment">// 1. 将参数进行绑定 bind2nd</span></span><br><span class="line">    <span class="comment">// bind1st 功能类似，不过n会被绑定到第一个参数中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="fang-han-shu-pei-jie-qi-zong-lan">仿函数配接器总览</h2>
<p><img src="/2022/05/18/STL%E5%89%96%E6%9E%90/356346.png" alt="356346"></p>
<h2 id="pei-jie-qi-shi-yong-jie-xi">配接器使用解析</h2>
<p><img src="/2022/05/18/STL%E5%89%96%E6%9E%90/25234.png" alt="25234"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
</search>
