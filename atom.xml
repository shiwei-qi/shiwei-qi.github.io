<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zmqNut</title>
  
  <subtitle>明知会散落， 仍不惧盛开</subtitle>
  <link href="https://shiwei-qi.github.io/atom.xml" rel="self"/>
  
  <link href="https://shiwei-qi.github.io/"/>
  <updated>2022-05-17T14:46:13.375Z</updated>
  <id>https://shiwei-qi.github.io/</id>
  
  <author>
    <name>shiwei-qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL剖析</title>
    <link href="https://shiwei-qi.github.io/2022/05/17/STL%E5%89%96%E6%9E%90/"/>
    <id>https://shiwei-qi.github.io/2022/05/17/STL%E5%89%96%E6%9E%90/</id>
    <published>2022-05-17T11:27:15.000Z</published>
    <updated>2022-05-17T14:46:13.375Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/05/17/STL%E5%89%96%E6%9E%90/34653464.png" alt="34653464" style="zoom:67%;"><h1 id="STL实现原理及实现"><a href="#STL实现原理及实现" class="headerlink" title="STL实现原理及实现"></a>STL实现原理及实现</h1><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是：容器、算法、迭代器、仿函数、适配器（配器）、空间配置器。</p><p>STL六大组件的交互关系：</p><ol><li>容器通过空间配置器取得数据存储空间</li><li>算法通过迭代器存储容器中的内容</li><li>仿函数可以协助算法完成不同的策略的变化</li><li>​4.适配器可以修饰仿函数。</li></ol><p><strong>容器</strong><br>各种数据结构，如vector、Iist、deque、set、map等，用来存放数据，从实现角度来看，STL容器是一种class template。</p><p><strong>算法</strong><br>各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p><p><strong>迭代器</strong><br>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将<code>operator*</code>, <code>operator-&gt;</code>, <code>operator++</code>, <code>operator--</code> 等指针相关操作予以重载的class template。</p><p>所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。<br>原生指针(native pointer)也是一种迭代器。</p><p><strong>仿函数</strong><br>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了<code>operator()</code>的class或者class template。</p><p><strong>适配器</strong><br>一种用来修饰容器或者仿函数或迭代器接口的东西。</p><p>STL提供的queue和stack,虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque, 所有操作都由底层的deque供应。</p><p><strong>空间配置器</strong><br>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。<br>一般的分配器的<code>std::alloctor</code>都含有两个函数<code>allocate</code>与<code>deallocte</code>,这两个函数分别调用<code>operator new()</code>与<code>delete()</code>,这两个函数的底层又分别是<code>malloc()</code> 和 <code>free()</code>; 但是每次malloc会带来格外开销（因为每次malloc一个元素都要带有附加信息）</p><h1 id="空间配置器（allocate-）"><a href="#空间配置器（allocate-）" class="headerlink" title="空间配置器（allocate()）"></a>空间配置器（<code>allocate()</code>）</h1><blockquote><p>SGI STL 为了避免小型区块的内存碎片（fragment）问题, SGI设计了两级配置器</p></blockquote><p>当配置区块大于128字节时，调用第一级配置器。小于128字节时调用第二级配置器。</p><p><strong>为什么这样区分成两级？</strong></p><p>​    因为STL容器，一般申请的都会是小块的内存。 二级空间配置器，主要是管理容器申请空间和释放的空间。如果用户申请的空间直接大于的<strong>128</strong>字节直接找的是一级空间配置器申请空间。</p><blockquote><p>一级空间配置器</p></blockquote><p>第一级配置器<strong>（alloc）</strong>的<code>allocate()</code>和<code>deallocate()</code>函数只是简单调用<code>malloc()</code>、<code>free()</code>和<code>relloc()</code>函数；</p><p>一级空间配置器原理很简单，直接是对malloc和free进行了封装，并且增加了C++中的set_new_handle思想，即申请空间失败抛异常机制。</p><blockquote><p>二级空间配置器</p></blockquote><p>第二级配置器为了降低额外开销（overhead），采用<strong>内存池</strong>(memory pool)管理内存分配；具体使用的内存块从free-list(自由链表)中提取出。</p><p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</p><img src="/2022/05/17/STL%E5%89%96%E6%9E%90/3453.png" alt="3453" style="zoom: 67%;"><p><strong>具体流程为：</strong></p><ul><li><p>空间配置函数<code>allocate()</code>，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</p></li><li><p>空间释放函数<code>deallocate()</code>，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</p></li></ul><p>1.当需要申请的内存大小N 大于128bytes时，直接使用第一级配置器，使用malloc分配</p><p>2.小于等于128bytes时，使用内存池管理。内存池管理步骤为：</p><p>​a. 首先查看是否有可用的free-list，如果有就直接使用。没有的话，将所需区块大小上调至8的倍数，调用  refill()为free list重新分配空间。</p><p>​b. 新的空间将取自内存池（经由chunk_alloc()完成），如果内存池不够用，从堆空间（malloc配置空间）  拿来补充内存池。如果堆空间也不够了，就调用第一级配置器来补充内存池。因为第一级配置器有out-of- memory处理机制，看看它能不能释放其它内存然后拿来此处使用（如果可以就成功，否则bad_alloc异常）。</p><p><strong>这里要注意一点，最初内存池和free list都为空。</strong></p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>STL的中心思想：将数据容器(containers)和算法(algorithms)分开，彼此独立设计，最后再以胶着剂将它们撮合在一起。那么之间的<strong>胶着剂就是迭代器(iterator)</strong></p><p>迭代器 iterator是一种<strong>智能指针</strong>(smart pointer)</p><p>迭代器是一种行为类似指针的对象(智能指针对象)，其行为包括内容提领(deference)和成员访问(member access)，所以迭代器要对<code>operator&amp;()</code>和<code>operator*()</code>进行重载，同时要兼顾自身的有效性(析构)的问题。</p><blockquote><p>在实际的算法中，在运用迭代器时，会用到迭代器所指对象中的相应类型(associate type)。</p></blockquote><p>那么算法实现中该如何满足 <strong>声明一个以“迭代器所指对象(中)的类型”为类型的成员&#x2F;参数，或返回值是“迭代器所指对象(中)的类型”的类型</strong> 的需求呢？</p><p>可分为以下三种情况：</p><p>​① 迭代器所指对象是c++内置类型；<br>​② 迭代器所指对象是自定义类型(class type)情形;<br>​③ 迭代器所指对象是原生指针(naive pointer)情形;</p><p>对应的运用以下三种方法解决：</p><p>​① function template的参数推导(augument deducation)机制 ；<br>​② 声明内嵌类型 ；<br>​③ 利用泛化中偏特化(partial secification)(下面有解释) ；<br>​envolve to ：萃取机 iterator_traits 机制</p><p><strong>这三种方法是逐步整合为最终的实现的方案就是 *iterator_traits萃取机* 机制，它包含了函数模板的参数推导，声明内嵌类型和偏特化所有内容，也同时解决了以上的三个场景的实现需求。</strong></p><p>结合以上三种情况和三种解决方法，最终设计出了<strong>迭代器萃取机这一中间层，其作用是萃取出迭代器的相关特性（也即是相应类型的取用），以屏蔽迭代器实现对算法实现的影响</strong></p><img src="/2022/05/17/STL%E5%89%96%E6%9E%90/20210305145003405.png" alt="img" style="zoom:80%;"><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>如何选择容器适配器：</p><p><img src="/2022/05/17/STL%E5%89%96%E6%9E%90/645624.png" alt="645624"></p><h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><h3 id="vector-向量"><a href="#vector-向量" class="headerlink" title="vector - 向量"></a>vector - 向量</h3><p>vector采用的数据结构非常简单，线性连续空间，它以两个迭代器<code>_Myfirst</code>和<code>_Mylast</code>分别指向配置得来的连续空间中已被使用的范围，并以迭代器<code>Myend</code>指向整块连续内存空间的尾端。</p><p>为了降低空间配置时的成本，vector实际配置的大小可能比用户端需求大一些，以备将来可能的扩充，这便是<strong>容量</strong>的概念</p><blockquote><p>所谓动态增加大小，并不是在原空间之后续接新空间（因为无法保证原空间之后尚有可配置的空间），而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。</p><p>因此，<strong>对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了</strong>。</p></blockquote><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>vector的底层其实仍然是定长数组，它能够实现动态扩容的原因是增加了避免数量谥出的操作。<br>首先需要指明的是vector中元素的数量（长度）n与它已分配内存最多能包含元素的数量（容量）N是不一致的，vector会分开存储这两个量。当向vector中添加元素时，如发现n&gt;N，那么容器会分配一个尺寸为<strong>2</strong>N的数组，然后将旧数据从原本的位置拷贝到新的数组中，再将原来的内存释放。尽管这个操作的渐进复杂度是O(n), 但是可以证明其均摊复杂度为O(1)。而在末尾删除元素和访问元素则都仍然是O(1)的开销。因此，只要对vector的尺寸估<br>计得当并善用<code>resize()</code>和<code>reserve()</code>,就能使得vector的效率与定长数组不会有太大差距。</p><h4 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h4><blockquote><p>vector有两个参数，一个是size，表示当前vector容器内存储的元素个数，一个是capacity，表示当前vector在内存中申请的这片区域所能容纳的元素个数</p></blockquote><p>vector 的reserve增加了vector的capacity，但是它的size没有改变！而resize改变了vector的capacity同时也增加了它的size！</p><p>原因如下：</p><ul><li><code>reserve</code>是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用 <strong>push_back()</strong> &#x2F; <strong>insert()</strong> 函数。</li><li><code>resize</code>是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用**operator[]**操作符，或者用迭代器来引用元素对象。此时再调用 <strong>push_back()</strong>     函数，是加在这个新的空间后面的。</li></ul><p> 两个函数的参数形式也有区别的，reserve函数之后一个参数，即需要预留的容器的空间；resize函数可以有两个参数，第一个参数是容器新的大小， 第二个参数是要加入容器中的新元素，如果这个参数被省略，那么就调用元素对象的默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vect;</span><br><span class="line">  </span><br><span class="line">    vect.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vect.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vect.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    vect.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    vect.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    cout&lt;&lt;vect.<span class="built_in">size</span>()&lt;&lt;endl;  <span class="comment">//size为4，但是capacity为10</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>reserve()</code> 使得vector 预留一定的内存空间，避免不必要的内存拷贝。</li><li><code>capacity()</code> 返回容器的容量，即不发生拷贝的情况下容器的长度上限。</li><li><code>shrink_to_fit()</code> 使得vector的容量与长度一致，多退但不会少。</li></ul><h4 id="vector的assign-函数用法"><a href="#vector的assign-函数用法" class="headerlink" title="vector的assign()函数用法"></a>vector的assign()函数用法</h4><p>函数原型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(const_iterator first,const_iterator last)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(size_type n,<span class="type">const</span> T&amp; x = T())</span></span>;</span><br></pre></td></tr></table></figure><p>第一个相当于个拷贝函数，把first到last的值赋值给调用者；（注意区间的闭合）</p><p>第二个把n个x赋值给调用者；</p><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">ls1.<span class="built_in">assign</span>(ls.<span class="built_in">begin</span>(),ls.<span class="built_in">begin</span>()+<span class="number">9</span>);</span><br><span class="line"><span class="comment">//打印为：0 1 2 3 4 5 6 7 8</span></span><br><span class="line">ls2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">//打印为：7777777777</span></span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>默认升序排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ul><li>降序排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>()); </span><br></pre></td></tr></table></figure><ul><li>自定义排序规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda函数</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; b;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//或者  </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a * a &lt; b * b;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(),cmp);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="最大元素（max-element）"><a href="#最大元素（max-element）" class="headerlink" title="最大元素（max_element）"></a>最大元素（max_element）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取最大元素所在迭代器</span></span><br><span class="line"><span class="keyword">auto</span> maxVal =  <span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最大元素所在位置</span></span><br><span class="line"><span class="type">int</span> maxIndex =  <span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()) - arr,<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul><li><p>vector和list由于查找某个元素是O(n)复杂度的，所以不提供<code>find()</code>。而set和map是由关键字排序，底层是红黑树，进行查找的话时间复杂度是O(logn)所以提供<code>find()</code></p></li><li><p>vector可以使用泛型find</p><p>  <code>find(vec.begin(), vec.end(), val) == vec.end();</code>  </p><p>如果vec中存储的是pair 类型，val最好先用<code>make_pair</code>定义好再去找</p></li><li><p>vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效。</p><p>list 的插入操作（insert）和接合操作（splice）都不会造成原有list迭代器失效。甚至list的元素删除操作（erase）也只有“指向被删除元素”的那个迭代器失效，其他迭代器不受任何影响</p></li></ul><h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string - 字符串"></a>string - 字符串</h3><p>头文件<code>&lt;string&gt;</code></p><blockquote><p>string 和 C风格字符串对比</p></blockquote><ul><li><p><code>char*</code>是一个指针，<code>string</code>是一个类</p><p><code>string</code>封装了<code>char*</code>，管理这个字符串，是一个<code>char*</code>型的容器。</p></li><li><p><code>string</code> 封装了很多实用的成员方法</p><p>查找<code>find</code>，拷贝<code>copy</code>，删除<code>erase</code>，替换<code>replace</code>，插入<code>insert</code>等</p></li><li><p>不用考虑内存释放和越界</p><p><code>string</code>管理<code>char*</code>所分配的内存，每一次<code>string</code>的复制&#x2F;赋值，取值都由<code>string</code>类负责维护，不用担心复制越界和取值越界等。</p><p><code>string</code> 本质上是一个动态的char数组。</p></li></ul><h4 id="转char数组"><a href="#转char数组" class="headerlink" title="转char数组"></a><strong>转char数组</strong></h4><p>在C语言里，也有很多字符串的函数，但是它们的参数都是char指针类型的，为了方便使用，string有两个成员函数能够将自己转换为char指针– <code>data()</code>&#x2F;<code>c_str()</code>(它们几乎是一样的，但最好使用<code>c_str()</code>,因为<code>c_str()</code>保证末尾有空字符，而<code>data（）</code>则不保证），如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="comment">//编译错误</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">data</span>()); <span class="comment">//编译通过，但是undefined behavior</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>()); <span class="comment">//一定能够正确输出</span></span><br></pre></td></tr></table></figure><h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a><strong>获取长度</strong></h4><p>许多函数可以返回string的长度：<code>s.size()</code>  <code>s.length()</code>  <code>strlen(s.c_str())</code></p><blockquote><p>这些函数的复杂度</p><p>strlen(s.c_str()) 的复杂度是与字符串长度线性相关的</p><p>size() 和 length() 复杂度在C++11中被指定为常数复杂度</p></blockquote><h4 id="寻找某字符（串）第一次出现的位置"><a href="#寻找某字符（串）第一次出现的位置" class="headerlink" title="寻找某字符（串）第一次出现的位置"></a><strong>寻找某字符（串）第一次出现的位置</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">//查找字符a第一次出现的位置</span></span><br><span class="line">s.<span class="built_in">find</span>(t) <span class="comment">//查找字符串t第一次出现的位置</span></span><br><span class="line">s.<span class="built_in">find</span>(t, pos) <span class="comment">//查找s中自pos位置起字符串t第一次出现的位置</span></span><br></pre></td></tr></table></figure><p>未找到返回-1</p><h4 id="截取子串"><a href="#截取子串" class="headerlink" title="截取子串"></a><strong>截取子串</strong></h4><p><code>substr(pos, len)</code>, 这个函数的参数是从pos位置开始截取最多len个字符（如果从pos开始的后缀长度不足len则截取这个后缀）</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><code>erase(pos)</code>和<code>erase(pos, len)</code>删除字符串中下标为pos开始的指定长度的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;123456789&quot;</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出为 123</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;123456789&quot;</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出为 12356789</span></span><br></pre></td></tr></table></figure><h4 id="string-和C-style-字符串的转换"><a href="#string-和C-style-字符串的转换" class="headerlink" title="string 和C-style 字符串的转换"></a><strong>string 和C-style 字符串的转换</strong></h4><ul><li>string 转 const char*</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure><ul><li>const char* 转 string</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(cstr)</span></span>; <span class="comment">//本质上其实是一个有参构造</span></span><br></pre></td></tr></table></figure><h4 id="string-replace详解"><a href="#string-replace详解" class="headerlink" title="string replace详解"></a>string replace详解</h4><blockquote><p><strong>replace算法：</strong></p><p>​        replace函数包含于头文件#include<string>中。</string></p><p>​        泛型算法replace把队列中与给定值相等的所有值替换为另一个值，整个队列都被扫描，即此算法的各个版本都在线性时间内执行——其复杂度为O(n)。</p><p>​        即replace的执行要遍历由区间[frist，last)限定的整个队列，以把old_value替换成new_value。</p></blockquote><p>下面说下replace()的九种用法：</p><ol><li><p><strong>用法一：用str替换指定字符串从起始位置pos开始长度为len的字符</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> string&amp; str)</span></span>; </span><br></pre></td></tr></table></figure></li><li><p><strong>用法二： 用str替换 迭代器起始位置 和 结束位置 的字符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">const</span> string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>用法三： 用substr的指定子串（给定起始位置和长度）替换从指定位置上的字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>用法四： 用str替换从指定位置0开始长度为5的字符串</strong> （string转char*时编译器可能会报出警告，不建议这样做）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>用法五：用str替换从指定迭代器位置的字符串</strong> （string转char*时编译器可能会报出警告，不建议这样做）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>用法六：用s的前n个字符替换从开始位置pos长度为len的字符串</strong> （string转char*时编译器可能会报出警告，不建议这样做）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>用法七：用s的前n个字符替换指定迭代器位置(从i1到i2)的字符串</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; </span><br></pre></td></tr></table></figure></li><li><p><strong>用法八：用重复n次的c字符替换从指定位置pos长度为len的内容</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>; </span><br></pre></td></tr></table></figure></li><li><p><strong>用法九： 用重复n次的c字符替换从指定迭代器位置（从i1开始到结束）的内容</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="list-链表"><a href="#list-链表" class="headerlink" title="list - 链表"></a>list - 链表</h3><p>链表是一种物理存储单元上非连、续非顺序的储存结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p><p>list 容器是一个双向链表，且是<strong>循环的双向链表</strong></p><p><img src="/2022/05/17/STL%E5%89%96%E6%9E%90/235346457.png" alt="235346457"></p><p>相较于vector的连续线性空间，list就显得复杂许多。</p><ul><li>它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间</li><li>因此，list对于空间的运用有绝对的精准，一点也不浪费</li><li>而且，list对于任何位置插入或删除元素都是常数项时间</li></ul><blockquote><p>list 有一个重要的性质，插入和删除操作都不会造成原有list迭代器的失效</p><ul><li>这在vector是不成立的，因为vector的插入操作可能会造成内存的重新配置，导致原有的迭代器全部失效</li><li>而list元素的删除只会使得被删除元素的迭代器失效</li></ul></blockquote><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul><li>顺序遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(list&lt;T&gt;::iterator it = lst.<span class="built_in">begin</span>(); it != lst.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逆序遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(list&lt;T&gt;::reverse_iterator it = lst.<span class="built_in">rbegin</span>(); it != lst.<span class="built_in">rend</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lstT; <span class="comment">// 默认构造形式，list采用模版类实现</span></span><br><span class="line"><span class="built_in">list</span>(beg, end); <span class="comment">// 构造函数将[beg, end)区间内的元素拷贝给本身</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">int</span> n, T elem); <span class="comment">// 构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list&amp; lst); <span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="元素插入和删除操作"><a href="#元素插入和删除操作" class="headerlink" title="元素插入和删除操作"></a>元素插入和删除操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T elem)</span></span>; <span class="comment">// 在容器尾部加入一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">// 删除容器中最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T elem)</span></span>; <span class="comment">// 在容器开头插入一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>; <span class="comment">// 从容器开头移除第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(iterator pos, elem); <span class="comment">// 在pos位置插入elem元素的拷贝，返回新数据的位置</span></span><br><span class="line"><span class="built_in">insert</span>(iterator pos, n, elem); <span class="comment">// 在pos位置插入n个elem元素的拷贝，无返回值</span></span><br><span class="line"><span class="built_in">insert</span>(iterator pos, beg, end); <span class="comment">// 在pos位置插入[beg, end)区间内的数据，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 移除容器的所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(beg, end); <span class="comment">// 删除[beg, end)区间内的所有数据，返回下一个数据的位置</span></span><br><span class="line"><span class="built_in">erase</span>(pos); <span class="comment">// 删除pos位置的数据，返回下一个数据的位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">remove</span>(elem); <span class="comment">// 删除容器中所有与elem匹配的元素</span></span><br></pre></td></tr></table></figure><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end); <span class="comment">// 将[beg, end)区间中的数据拷贝赋值给本身</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem); <span class="comment">// 将n个elem拷贝赋值给本身</span></span><br><span class="line"></span><br><span class="line">list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list&amp; lst); <span class="comment">// 重载等号操作符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(lst); <span class="comment">// 将lst与本身的元素互换</span></span><br></pre></td></tr></table></figure><h4 id="反转及排序"><a href="#反转及排序" class="headerlink" title="反转及排序"></a>反转及排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>; <span class="comment">// 反转链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>; <span class="comment">// 默认list排序，规则为从小到大</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">bool</span> (*cmp)(T item1, T item2))</span></span>; <span class="comment">// 指定排序规则的list排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为所有系统提供的某些算法（比如排序），其迭代器必须支持随机访问</span></span><br><span class="line"><span class="comment">// 不支持随机访问的迭代器的容器，容器本身会对应提供相应的算法的接口</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能用sort(lst.begin(), lst.end())</span></span><br><span class="line"><span class="comment">//应该使用下列形式</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; p1, T&amp; p2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> p1.val &lt; p2.val;</span><br><span class="line">&#125;</span><br><span class="line">ls.<span class="built_in">sort</span>(myCompare);</span><br></pre></td></tr></table></figure><h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><h1 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h1>]]></content>
    
    
    <summary type="html">C++标准模板库STL相关知识，主要内容基于侯捷的《STL源码剖析》。</summary>
    
    
    
    <category term="C++" scheme="https://shiwei-qi.github.io/categories/C/"/>
    
    <category term="STL" scheme="https://shiwei-qi.github.io/categories/C/STL/"/>
    
    
    <category term="C++" scheme="https://shiwei-qi.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://shiwei-qi.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Git及相关操作</title>
    <link href="https://shiwei-qi.github.io/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>https://shiwei-qi.github.io/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</id>
    <published>2022-05-06T15:05:31.000Z</published>
    <updated>2022-05-17T07:57:15.616Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/1576218250849.png" alt="1576218250849" style="zoom: 67%;"><h1 id="ban-ben-kong-zhi">版本控制</h1><blockquote><p>版本控制是一种在开发过程中用于管理我们对文件、目录工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p></blockquote><blockquote><p><strong>版本控制分类</strong></p></blockquote><ol><li><p><strong>本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人使用，如RCS。</p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506144248059.png" alt="image-20220506144248059" style="zoom:80%;"></li><li><p><strong>集中版本控制</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506144736888.png" alt="image-20220506144736888" style="zoom:80%;"><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS。</p></li><li><p><strong>分布式版本控制</strong></p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506145700293.png" alt="image-20220506145700293" style="zoom:80%;"></li></ol><blockquote><p>Git和SVN最主要的区别</p></blockquote><p><strong>SVN</strong>是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p><strong>Git</strong>是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git是目前世界上最先进的分布式版本控制系统。</p><p>==Git是目前世界上最先进的分布式版本控制系统==</p><h1 id="git-huan-jing-pei-zhi">Git环境配置</h1><blockquote><p>软件下载</p></blockquote><p>打开 git官网： <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p><p>所有东西下载慢的话就可以去找镜像！</p><p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506151614414.png" alt="image-20220506151614414" style="zoom:50%;"><p>下载对应的版本即可安装！</p><p>安装：无脑下一步即可！安装完毕就可以使用了！</p><blockquote><p>启动Git</p></blockquote><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p><p>**Git Bash：**Unix与Linux风格的命令行，使用最多，推荐最多</p><p>**Git CMD：**Windows风格的命令行</p><p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><blockquote><p>常用的Linux命令</p></blockquote><p>1）cd : 改变目录。</p><p>2）cd . . 回退到上一个目录，直接cd进入默认目录</p><p>3）pwd : 显示当前所在的目录路径。</p><p>4）ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p><p>5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p><p>6）rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p><p>7）mkdir:  新建一个目录,就是新建一个文件夹。</p><p>8）rm -r :  删除一个文件夹, rm -r src 删除src目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！</span><br></pre></td></tr></table></figure><p>9）mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p><p>10）reset 重新初始化终端/清屏。</p><p>11）clear 清屏。</p><p>12）history 查看命令历史。</p><p>13）help 帮助。</p><p>14）exit 退出。</p><p>15）#表示注释</p><blockquote><p>Git配置</p></blockquote><p>查看配置 <code>git config -l</code></p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506160111412.png" alt="image-20220506160111412" style="zoom:80%;"><p>查看不同级别的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看系统config</span></span><br><span class="line">git config --system --list</span><br><span class="line">　　</span><br><span class="line"><span class="comment">#查看当前用户（global）配置</span></span><br><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure><p><strong>Git相关的配置文件：</strong></p><p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   --system 系统级</p><p>2）、C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  --global 全局</p><blockquote><p>设置用户名与邮箱（用户标识，必要）</p></blockquote><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;user&quot;</span>  <span class="comment">#名称</span></span><br><span class="line">git config --global user.email user@XXX.com   <span class="comment">#邮箱</span></span><br></pre></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506161314084.png" alt="image-20220506161314084"></p><h1 id="git-ji-ben-li-lun">Git基本理论</h1><blockquote><p>三个区域</p></blockquote><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/3214.png" alt="3214" style="zoom:80%;"><ul><li>Workspace：<strong>工作区</strong>，就是你平时存放项目代码的地方</li><li>Index / Stage：<strong>暂存区</strong>，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：<strong>仓库区</strong>（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：<strong>远程仓库</strong>，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/image-20220506210730715.png" alt="image-20220506210730715" style="zoom: 50%;"><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><blockquote><p><strong>工作流程</strong></p></blockquote><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/640.jpg" alt="640" style="zoom: 67%;"><h1 id="git-xiang-mu-da-jian">Git项目搭建</h1><blockquote><p>创建工作目录与常用指令</p></blockquote><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/640.png" alt="640" style="zoom:80%;"><blockquote><p>本地仓库搭建</p></blockquote><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><blockquote><p>克隆远程仓库</p></blockquote><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><p>2、去 gitee 或者 github 上克隆一个测试！</p><h1 id="git-wen-jian-cao-zuo">Git文件操作</h1><blockquote><p>文件的四种状态</p></blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li><strong>Staged</strong>: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><blockquote><p>查看文件状态</p></blockquote><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看指定文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># git add .                  添加所有文件到暂存区</span></span><br><span class="line"><span class="comment"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br></pre></td></tr></table></figure><blockquote><p>忽略文件</p></blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       #忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h1 id="yuan-cheng-cang-ku">远程仓库</h1><p>远程仓库可以选用Github或者Gitee等常用仓库，设置本机绑定SSH公钥，实现免密码登录等操作本处不做详细介绍。</p><p>1、新建项目，绑定git。</p><p>2、修改文件，使用IDEA操作git。</p><ul><li><p>添加到暂存区</p></li><li><p>commit 提交</p></li><li><p>push到远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">#如果本地分支名与远程分支名相同，则可以省略冒号：</span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line">#eg:以下命令将本地的 master 分支推送到 origin 主机的 master 分支</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></li></ul><p>3、提交测试</p><h1 id="shuo-ming-git-fen-zhi">说明：GIT分支</h1><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p><p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/235235.png" alt="235235"></p><p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/54675.png" alt="54675"></p><p>git分支中常用指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><p>IDEA中操作</p><p><img src="/2022/05/06/Git%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/235423.png" alt="235423"></p><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>]]></content>
    
    
    <summary type="html">Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</summary>
    
    
    
    <category term="工具类" scheme="https://shiwei-qi.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="Git" scheme="https://shiwei-qi.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Typora使用教程及MarkDown语法</title>
    <link href="https://shiwei-qi.github.io/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/"/>
    <id>https://shiwei-qi.github.io/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/</id>
    <published>2022-05-06T14:51:55.000Z</published>
    <updated>2022-05-17T10:45:51.279Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/girl-16518503155441.jpg" alt="girl"></p><h1 id="markdown-yu-typora-jie-shao">Markdown与Typora介绍</h1><h2 id="markdown-jie-shao">Markdown介绍</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 .md, .markdown</p></blockquote><h2 id="typora-jie-shao-yu-xia-zai">Typora介绍与下载</h2><p>Typora编辑器让人们能更简单地用Markdown语言书写文字，解决了使用传统的Markdown编辑器写文的痛点，并且界面简洁优美，实现了实时预览等功能。</p><p>Typora官网： <a href="https://typora.io/">https://typora.io/</a></p><h1 id="markdown-yu-fa">Markdown语法</h1><h2 id="biao-ti">标题</h2><p>使用 <code>#</code> 可以表示标题，一级标题对应一个 <code>#</code> ，二级标题对应两个 <code>#</code> 号，最多至六级标题。在Typora中，<code>#</code> 后要紧接着一个空格才能表示标题，否则就是普通字符。</p><p>在Typora中，也可以使用快捷键<strong>Ctrl+1</strong>（2，3，4，5，6）表示相对应的标题。<strong>Ctrl+0</strong>表示段落。标题快捷键信息可在菜单栏中的段落选项下查看。</p><h2 id="zi-ti">字体</h2><ul><li><p>用一对星号括住的文本表示斜体文本，如：<code>*</code>要变斜体的文本<code>*</code>，<em>斜体文本</em> ；</p></li><li><p>也可以用一对下划线括住文本来表示斜体文本，如：<code>_</code>要变斜体的文本<code>_</code>，<em>斜体文本</em> ；</p></li></ul><p>也可以使用Typora的快捷键<strong>Ctrl+I</strong>来表示斜体文本。</p><ul><li><p>用一对<code>**</code>括住的文本表示粗体文本，如：<code>**</code>要变粗体的文本<code>**</code>，<strong>粗体文本</strong>；</p></li><li><p>也可以用一对<code>__</code>括住的文本来表示粗体文本，如：<code>__</code>要变粗体的文本<code>__</code>，<strong>粗体文本</strong>；</p></li></ul><p>也可以使用Typora的快捷键<strong>Ctrl+B</strong>来表示粗体文本。</p><p>用一对<code>***</code>括住的文本表示粗斜体文本，如：<code>***</code>要变粗斜体的文本<code>***</code>，<em><strong>粗斜体文本</strong></em>；<br>也可以用一对<code>___</code>括住的文本来表示粗斜体文本，如：<code>___</code>要变粗斜体的文本<code>___</code>，<em><strong>粗斜体文本</strong></em></p><h2 id="ge-chong-xian">各种线</h2><ul><li>分割线，可以使用<strong>三个及以上</strong>的 <code>+</code> 号或 <code>*</code> 号或 <code>-</code> 来表示一条分割线；</li></ul><hr><ul><li>删除线，可以使用一对<code>~~</code>括住的文本来表示删除文本，如：<code>~~</code>要加删除线的文本<code>~~</code>，<s>删除文本</s>；在Typora中，也可以使用快捷键<strong>Alt+Shift+5</strong>来加删除线，语法相同，<s>删除线</s>。</li><li>下划线，可以使用HTML的标签<code>&lt;u&gt;</code>和<code>&lt;/u&gt;</code>表示增加下划线的文本，如：<code>&lt;u&gt;</code>要增加下划线的文本<code>&lt;/u&gt;</code>，<u>下划线</u>；在Typora中，也可以使用快捷键<strong>Ctrl+U</strong>来增加下划线，语法也是相同的，<u>下划线</u>。</li></ul><h2 id="lie-biao">列表</h2><p><strong>无序列表</strong></p><p>可以使用<code>*</code>，<code>+</code>或<code>-</code>标记符号来表示无序列表项，记住要在标记符号后<strong>添加一个空格</strong>，语法显示如下：</p><p>在Typora中可以使用快捷键<strong>Ctrl + Shift + ]</strong> 、<strong>Ctrl + Shift + [</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br></pre></td></tr></table></figure><h2 id="strong-you-xu-lie-biao-strong"><strong>有序列表</strong></h2><p>可以使用<strong>数字加上<code>.</code>再加上空格</strong>来表示有序列表，语法如下：</p><p>在Typora中可以使用快捷键<strong>Ctrl + Shift + [</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">3. 第二项</span><br><span class="line">10. 第三项</span><br></pre></td></tr></table></figure><p><strong>嵌套列表</strong></p><p>首先使用<code>*</code>、<code>+</code>或<code>-</code>进入列表，然后回车换行，会发现系统自动生成列表第二项，此时按下<strong>Tab</strong>键，列表第二项变为第一项的子列表。<strong>按回车退出当前列表</strong>。可以在无序列表中嵌套有序列表, 也可以在有序列表中嵌套无序列表。</p><ol><li>一级<ol><li>一一级</li><li>一二级<ul><li>一二一级</li><li>一二二级</li></ul></li><li>一三级</li></ol></li><li>二级</li></ol><p>快捷键<strong>Shift + tab</strong> ——返回上一级列表</p><h2 id="qu-kuai">区块</h2><p>当我们想要引用别人的文章内容时，可以将其放在区块内。</p><p>可以使用<code>&gt;</code>加空格来表示区块。</p><blockquote><p>一级区块</p><blockquote><p>二级区块</p><blockquote><p>三级区块</p></blockquote><p>二级区块</p></blockquote></blockquote><p>要退出区块，同样使用<code>Enter</code>键即可</p><h2 id="dai-ma">代码</h2><p>如果是一行代码，可以使用段内代码块来表示，用一对 <strong>`</strong>（数字1旁边的符号）括住代码。</p><p>比如<code>printf(&quot;Hello World!&quot;)</code></p><p>如果是代码段，那么可以使用<strong>三个 ` 加Enter/空格+编程语言</strong>来表示。使用快捷键<strong>ctrl + shift + k</strong>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lian-jie">链接</h2><p>链接的使用方式有两种语法，如下：</p><p><code>[</code>链接文字<code>]</code> <code>(</code>链接地址<code>)</code><br>或<br><code>[</code>链接文字<code>]</code> <code>()</code></p><p>示例如下：按住<strong>Ctrl+鼠标左键</strong>点击访问。</p><p><a href="https://www.baidu.com/">百度</a><br><a href="https://www.baidu.com/">https://www.baidu.com/</a></p><p>链接除了可以打开相应的网页外，还可以<strong>打开本地文件</strong>，使用方式类似，不过链接地址需要使用本地文件的地址，相对地址、绝对地址均可：</p><p><code>[</code>打开LinkTest.md文档<code>]</code> <code>(</code>./LinkTest.md<code>)</code></p><p>我们也可以使用链接来实现<strong>页内跳转</strong>，语法为：</p><p><code>[</code>链接文字<code>]</code> <code>(</code>#标题文字<code>)</code></p><p>eg: <a href="#Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E5%8F%8AMarkDown%E8%AF%AD%E6%B3%95">跳到首页</a></p><h2 id="tu-pian">图片</h2><p>我们也可以在Markdown文档中插入图片，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><ul><li>首先一个感叹号</li><li>然后中括号里面写属性文本</li><li>小括号里面写图片地址，后可接标题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![本地png图片PictureTest.png](./img/PictureTest.png)</span><br><span class="line"></span><br><span class="line">![本地jpg图片](./img/PictureTest.jpg)</span><br><span class="line"></span><br><span class="line">![网络图片](http://static.runoob.com/images/runoob-logo.png &quot;菜鸟教程&quot;)</span><br></pre></td></tr></table></figure><p>在Typora中，也可以直接使用<code>Ctrl+C</code>，<code>Ctrl+V</code>来直接进行复制粘贴图片，但是，由于Markdown是需要图片的地址的，所以需要简单设置一下Typora。</p><p>点击文件 --&gt; 偏好设置 --&gt; 图像，如下：</p><p><img src="/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjYxMjUx,size_16,color_FFFFFF,t_70-16518503155442.png" alt="img"></p><p>可以自行设置选择将图片复制到哪个文件夹。</p><p><img src="/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/20191108173139695-16518503155444.png" alt="img"></p><p>这里选择复制到指定路径，然后在下面一栏中填写./img，表示将图片复制到你正在编辑的文档同一级的img文件夹下。在下面的选项中，勾选第一、二、三项。正因为勾选了第二项，所以当我们在插入网络图片时，Typora会自动帮我们将网络图片下载到指定的路径下，前面的&quot;菜鸟教程&quot;图片便是如此。</p><p>由于Markdown的特殊语法，故经常会出现图片加载失败的情况，很大的可能就是因为在指定的路径上找不到相应的图片，当然，有时候也是由于Typora的原因，重启Typora即可</p><h2 id="yan-se-zi-ti">颜色字体</h2><p>替换对应颜色代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$\color&#123;#FF3030&#125;&#123;red&#125;$</span><br><span class="line"></span><br><span class="line">$\color&#123;#0000CD&#125;&#123;blue&#125;$</span><br><span class="line"></span><br><span class="line">$\color&#123;#33ff66&#125;&#123;green&#125;$</span><br><span class="line"></span><br><span class="line">$\color&#123;#ffff00&#125;&#123;yellow&#125;$</span><br></pre></td></tr></table></figure><p><img src="/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/image-20220506232014009.png" alt="image-20220506232014009"></p><h2 id="biao-ge">表格</h2><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">|---|---|----|</span><br><span class="line">|单元格|单元格|单元格|</span><br><span class="line">|单元格|单元格|单元格|</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td><td>单元格</td></tr></tbody></table><p>我们可以设置对齐方式：</p><ul><li><code>:-</code>表示左对齐</li><li><code>-:</code>表示右对齐</li><li><code>:-:</code>表示中间对齐</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|左对齐|右对齐|中间对齐|</span><br><span class="line">|:---|---:|:----:|</span><br><span class="line">|单元格|单元格|单元格|</span><br><span class="line">|单元格|单元格|单元格|</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">中间对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table><p>在Typora中，我们可以使用快捷键<strong>Ctrl+T</strong>来插入表格，并选择行列，当选中表格某一单元格时，可以在表格左上角手动设置对齐方式，右上角选择更多操作。</p><h1 id="typora-yu-shu-xue-gong-shi">Typora与数学公式</h1><h2 id="ru-he-cha-ru-shu-xue-gong-shi">如何插入数学公式</h2><p>在Typora中，有两种方法插入数学公式，语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一种方法：$数学公式$</span><br><span class="line">第二种方法：</span><br><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>第一种方法表示插入行内公式（内联公式），即可以将公式插入到一行中，比如$1 + 2 = 3$ 这样的公式。</p><p>第二种方法表示插入行间公式（外联公式），即可以将公式插入到行与行之间，单独占据一行或者数行的空间，并且居中放置。<br>$$<br>1+2=3<br>$$<br>如果要在行间公式内换行，在换行的位置使用<code>\\</code></p><p>常用符号、上下标、根号、括号、运算符等此处不做详细介绍</p><h1 id="typora-yu-html">Typora与HTML</h1><h2 id="gai-bian-zi-ti-yan-se-ji-da-xiao">改变字体颜色及大小</h2><p>我们可以使用<code>&lt;font&gt; &lt;/font&gt;</code>标签来改变字体的颜色及大小，如：</p><p>属性<code>size</code>表示字体大小，<code>color</code>表示颜色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size=3 color=&quot;red&quot;&gt;字体颜色为红色，大小为3&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font size=4 color=&quot;blue&quot;&gt;字体颜色为蓝色，大小为4&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font size=6 color=&quot;violet&quot;&gt;字体颜色为紫罗兰，大小为6&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><font size="3" color="red">字体颜色为红色，大小为3</font></p><p><font size="4" color="blue">字体颜色为蓝色，大小为4</font></p><p><font size="6" color="violet">字体颜色为紫罗兰，大小为6</font></p><h2 id="gai-bian-dui-qi-fang-shi">改变对齐方式</h2><p>我们可以改变字体的对齐方式，用标签<code>&lt;p&gt; &lt;/p&gt;</code>加上属性<code>align</code>，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p align=&quot;left&quot;&gt;左对齐&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;center&quot;&gt;中间对齐&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;</span><br></pre></td></tr></table></figure><p align="left">左对齐</p><p align="left">左对齐</p><p align="center">中间对齐</p><p align="right">右对齐</p><h2 id="cha-ru-tu-xiang">插入图像</h2><p>因为CSDN不支持使用img标签修改图像，所以下面的结果都不是准确的。大家可以自己在Typora中测试。<br>我们可以通过标签<code>&lt;img src=url /&gt;</code>来插入图片，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;img/3.jpg&quot; /&gt;</span><br></pre></td></tr></table></figure><p>我们可以改变<code>&lt;img&gt;</code>标签的属性，来改变图片的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;img/3.jpg&quot; width=100 height=100/&gt;</span><br></pre></td></tr></table></figure><img src="/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/3-16518503155443.jpg" width="100" height="100/"><p>我们可以改变<code>&lt;img&gt;</code>标签的属性，来改变图片的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;img/3.jpg&quot; width=30 height=30 style=&quot;float:left&quot;/&gt;图片在左边</span><br><span class="line">&lt;img src=&quot;img/3.jpg&quot; width=30 height=30 style=&quot;float:right&quot;/&gt;图片在右边</span><br></pre></td></tr></table></figure><p><img src="/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/3-16518503155443.jpg" width="100" height="100" style="float:left">图片在左边</p><img src="/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/3-16518503155443.jpg" width="100" height="100" style="float:right"><p>图片在右边</p><h1 id="kuo-zhan-yong-fa">扩展用法</h1><h2 id="cha-ru-emoji-biao-qing">插入emoji表情</h2><p>我们可以使用<code>:emoji:</code>的语法来插入表情，比如：</p><p>:happy:的语法为<code>:happy:</code></p><p>🦀的语法为<code>:crab:</code></p><p>🐴的语法为<code>:horse:</code></p><h2 id="cha-ru-mu-lu">插入目录</h2><p>当我们为使用标题将文分章节后，可以在输入<code>[toc]</code>命令的地方自动根据标题生成目录。</p><h2 id="wen-ben-gao-liang">文本高亮</h2><p>在Typora中，可以用一对<code>==</code>将要高亮的文本括起来，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==要高亮的文本==</span><br><span class="line">==背景会用黄色填充==</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="/2022/05/06/Typora%E5%92%8CMarkDown%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B/image-20220506233054585.png" alt="image-20220506233054585"></p><p>这个功能可在偏好设置 --&gt; Markdown扩展语法中设置。</p>]]></content>
    
    
    <summary type="html">本文简单介绍了Typora软件的使用以及MarkDown基本语法。</summary>
    
    
    
    <category term="工具类" scheme="https://shiwei-qi.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="MarkDown" scheme="https://shiwei-qi.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <link href="https://shiwei-qi.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://shiwei-qi.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-04-22T13:48:16.000Z</published>
    <updated>2022-04-22T13:59:17.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jian-jie-tcp-san-ci-wo-shou-he-si-ci-hui-shou">简解TCP三次握手和四次挥手</h1><p>三次握手发生在客户端连接的时候，当调用connect(), 底层会通过TCP协议进行三次握手</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jian-jie-tcp-san-ci-wo-shou-he-si-ci-hui-shou&quot;&gt;简解TCP三次握手和四次挥手&lt;/h1&gt;
&lt;p&gt;三次握手发生在客户端连接的时候，当调用connect(), 底层会通过TCP协议进行三次握手&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://shiwei-qi.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://shiwei-qi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
